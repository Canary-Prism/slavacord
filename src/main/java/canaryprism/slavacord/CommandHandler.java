/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package canaryprism.slavacord;

import canaryprism.discordbridge.api.DiscordApi;
import canaryprism.discordbridge.api.DiscordBridge;
import canaryprism.discordbridge.api.DiscordBridgeApi;
import canaryprism.discordbridge.api.channel.ChannelType;
import canaryprism.discordbridge.api.channel.ServerChannel;
import canaryprism.discordbridge.api.event.interaction.SlashCommandAutocompleteEvent;
import canaryprism.discordbridge.api.event.interaction.SlashCommandInvokeEvent;
import canaryprism.discordbridge.api.interaction.slash.*;
import canaryprism.discordbridge.api.listener.interaction.SlashCommandAutocompleteListener;
import canaryprism.discordbridge.api.listener.interaction.SlashCommandInvokeListener;
import canaryprism.discordbridge.api.message.MessageFlag;
import canaryprism.discordbridge.api.misc.DiscordLocale;
import canaryprism.discordbridge.api.server.permission.PermissionType;
import canaryprism.slavacord.annotations.*;
import canaryprism.slavacord.annotations.optionbounds.ChannelTypeBounds;
import canaryprism.slavacord.annotations.optionbounds.DoubleBounds;
import canaryprism.slavacord.annotations.optionbounds.LongBounds;
import canaryprism.slavacord.annotations.optionbounds.StringLengthBounds;
import canaryprism.slavacord.autocomplete.AutocompleteSuggestion;
import canaryprism.slavacord.autocomplete.annotations.Autocompleter;
import canaryprism.slavacord.autocomplete.annotations.Autocompletes;
import canaryprism.slavacord.autocomplete.annotations.SearchSuggestions;
import canaryprism.slavacord.data.*;
import canaryprism.slavacord.data.autocomplete.AutocompletableData;
import canaryprism.slavacord.data.autocomplete.filter.AutocompleteFilter;
import canaryprism.slavacord.data.autocomplete.filter.AutocompleteFilterData;
import canaryprism.slavacord.data.optionbounds.*;
import canaryprism.slavacord.exceptions.ParsingException;
import canaryprism.slavacord.util.Reflection;
import org.apache.commons.lang3.reflect.TypeUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.jetbrains.annotations.Contract;
import org.jetbrains.annotations.NotNull;

import java.lang.annotation.Annotation;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.reflect.*;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * <h2>The main command handler of this library.</h2>
 * 
 * <p>
 * This class is responsible for handling all the commands and command groups
 * </p>
 */
public class CommandHandler {

    private static final Logger logger = LogManager.getLogger(CommandHandler.class);

    private static final long BOUNDS_MAX = 1L << 53;
    private static final long BOUNDS_MIN = -BOUNDS_MAX;

    private final DiscordBridge bridge;
    private final DiscordApi api;

    private final SlashCommandInvokeListener listener;
    private final SlashCommandAutocompleteListener autocomplete_listener;

    private final ArrayList<SlashCommandData> commands = new ArrayList<>();
    
    private final Map<Method, MethodHandle> methodmap = new HashMap<>();

    /**
     * <p>Creates a new CommandHandler with the given DiscordApi</p>
     * @param api the DiscordApi to use, cannot be null
     */
    public CommandHandler(Object api) {
        this.api = DiscordBridge.load(Objects.requireNonNull(api, "DiscordApi cannot be null"));
        this.bridge = this.api.getBridge();

        this.listener = this::listener;

        this.api.addSlashCommandInvokeListener(listener);
        logger.debug("added SlashCommandCreateListener");

        this.autocomplete_listener = this::autocompleteListener;

        this.api.addSlashCommandAutocompleteListener(autocomplete_listener);
        logger.debug("added AutocompleteCreateListener");
    }
    

    private void listener(SlashCommandInvokeEvent e) {
        var interaction = e.getSlashCommandInteraction();
        var names = interaction.getFullCommandName().toArray(String[]::new);

        synchronized (commands) {
            commands.stream()
                .filter((command) ->
                    command.server_id() == interaction.getServerCommandServerId().orElse(0L))
                .forEach((command) -> findMethodAndExecute(names, 0, interaction, interaction, command, null));
        }
        logger.debug("SlashCommandCreateEvent processed: {}", interaction.getFullCommandName());
    }

    private void autocompleteListener(SlashCommandAutocompleteEvent e) {
        var interaction = e.getSlashCommandAutocompleteInteraction();
        var names = interaction.getFullCommandName().toArray(String[]::new);

        synchronized (commands) {
            commands.stream()
                .filter((command) ->
                    command.server_id() == interaction.getServerCommandServerId().orElse(0L))
                .forEach((command) -> findMethodAndAutocomplete(names, 0, interaction, interaction, command, null));
        }
        logger.debug("AutocompleteCreateEvent processed: {}", interaction.getFullCommandName());
    }

    private static final MethodHandle get_implementation_handle;

    static {
        try {
            get_implementation_handle = MethodHandles.lookup().findVirtual(DiscordBridgeApi.class, "getImplementation", MethodType.methodType(Object.class));
        } catch (NoSuchMethodException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    private void findMethodAndExecute(String[] names, int index, SlashCommandInteraction interaction, SlashCommandInteractionOptionProvider interaction_options, SlashCommandData command, SlashCommandOptionData<?> option) {

        String looking_for = names[index];

        logger.trace("looking for command segment: {}", looking_for);

        Method method;
        Object instance;
        String name;
        List<? extends SlashCommandOptionData<?>> options;
        boolean requires_interaction;
        boolean interaction_uses_implementation_type;
        if (command == null) {
            method = option.method();
            instance = option.instance();
            name = option.name();
            options = option.options();
            requires_interaction = option.requires_interaction();
            interaction_uses_implementation_type = option.interaction_uses_implementation_type();
        } else {
            method = command.method();
            instance = command.instance();
            name = command.name();
            options = command.options();
            requires_interaction = command.requires_interaction();
            interaction_uses_implementation_type = command.interaction_uses_implementation_type();
        }

        if (name.equals(looking_for)) {
            logger.trace("found command segment: {}", looking_for);
            if (index == names.length - 1) {
                logger.trace("found final command segment");
                if (method == null) {
                    throw new IllegalArgumentException("SlashCommandData has no method");
                }

                if (!methodmap.containsKey(method)) {
                    try {
                        logger.trace("unreflecting Method to MethodHandle: {}", method);
                        methodmap.put(method, MethodHandles.lookup().unreflect(method));
                    } catch (IllegalAccessException e) {
                        throw new NoSuchElementException(e);
                    }
                }
                var handle = Objects.requireNonNull(methodmap.get(method));
                var parameters = new ArrayList<Object>();
                if (!Modifier.isStatic(method.getModifiers())) {
                    logger.trace("Method is not static, adding instance to parameters");
                    parameters.add(Objects.requireNonNull(instance, "Instance not found for non-static method"));
                }
                if (requires_interaction) {
                    logger.trace("Method requires interaction, adding interaction to parameters");
                    if (interaction_uses_implementation_type)
                        parameters.add(interaction.getImplementation());
                    else
                        parameters.add(interaction);
                }
                if (options != null) {
                    logger.trace("Method has options, parsing options");
                    for (SlashCommandOptionData<?> slash_command_option_data : options) {
                        logger.trace("parsing option: {}", slash_command_option_data);
                        var option_type = slash_command_option_data.type();
                        var uses_implementation_type = slash_command_option_data.uses_implementation_type();
                        boolean is_required = slash_command_option_data.required();
                        var option_name = slash_command_option_data.name();
                        if (!slash_command_option_data.stores_enum()) {
                            var opt_value = interaction_options.getArgumentByName(option_name)
                                    .orElseThrow()
                                    .getValue();

                            if (uses_implementation_type) {
                                logger.trace("option uses implementation type, unwrapping");
                                opt_value = opt_value.map((e) -> {
                                    try {
                                        return get_implementation_handle.invoke(((DiscordBridgeApi) e));
                                    } catch (Throwable ex) {
                                        throw new RuntimeException("couldn't get the implementation value", ex);
                                    }
                                });
                            }

                            if (is_required)
                                //noinspection OptionalGetWithoutIsPresent
                                parameters.add(opt_value.get());
                            else
                                parameters.add(opt_value);
                        } else {
                            logger.trace("option stores enum, reconstructing enum value");
                            if (option_type != SlashCommandOptionType.INTEGER) {
                                throw new IllegalArgumentException("Invalid option type for enum");
                            }
                            if (is_required) {
                                parameters.add(slash_command_option_data.choices().get(
                                                interaction_options.getArgumentByName(
                                                        slash_command_option_data.name())
                                                    .orElseThrow()
                                                    .getValue(Long.class)
                                                    .orElseThrow()
                                                    .intValue()
                                        ).value()
                                );
                            } else {
                                if (interaction_options.getArgumentByName(slash_command_option_data.name())
                                    .map((e) -> e.getValue(Long.class))
                                    .isPresent())
                                    parameters.add(Optional.of(
                                            slash_command_option_data.choices().get(
                                                    interaction_options.getArgumentByName(
                                                            slash_command_option_data.name())
                                                        .orElseThrow()
                                                        .getValue(Long.class)
                                                        .orElseThrow()
                                                        .intValue()
                                            ).value()
                                    ));
                                else
                                    parameters.add(Optional.empty());
                            }
                        }
                    }
                }

                final Async async = getAnnotationRecursive(method, Async.class);
                final ReturnsResponse returns_response = method.getDeclaredAnnotation(ReturnsResponse.class);

                if (async == null) {
                    logger.trace("Method is not async, executing immediately");
                    try {
                        Object returned = handle.invokeWithArguments(parameters);
                        
                        if (returns_response != null) {
                            processImmediateRespond(interaction, returns_response, method.getGenericReturnType(), returned);
                        }
                    } catch (Throwable e) {
                        logger.error("Exception in event listener thread: ", e);
                    }
                } else {
                    logger.trace("Method is async, dispatching to thread");
                    dispatchThreaded(() -> {
                        try {

                            if (returns_response != null) {
                                if (async.respondLater()) {
                                    var responder = interaction.respondLater(returns_response.ephemeral()).join();
                                    Object returned = handle.invokeWithArguments(parameters);

                                    var opt_text = getReturnedResponse(method.getGenericReturnType(), returned);
                                    if (opt_text.isPresent()) {
                                        var text = opt_text.get();

                                        if (returns_response.ephemeral()) {
                                            responder.setFlags(MessageFlag.EPHEMERAL);
                                        }
                                        if (returns_response.silent()) {
                                            responder.setFlags(MessageFlag.SILENT);
                                        }

                                        if (returns_response.splitOnLimit()) {
                                            var split = splitString(text, 2000);
                                            responder.setContent(split[0]);
                                            responder.update().join();

                                            var followup = interaction.createFollowupResponder();

                                            if (returns_response.ephemeral()) {
                                                followup.setFlags(MessageFlag.EPHEMERAL);
                                            }
                                            if (returns_response.silent()) {
                                                followup.setFlags(MessageFlag.SILENT);
                                            }

                                            for (int i = 1; i < split.length; i++) {
                                                followup.setContent(split[i]);
                                                followup.send().join();
                                            }

                                        } else {
                                            responder.setContent(text);
                                            responder.update().join();
                                        }
                                    }
                                } else {
                                    Object returned = handle.invokeWithArguments(parameters);
                                    processImmediateRespond(interaction, returns_response, method.getGenericReturnType(), returned);
                                }


                            } else {
                                handle.invokeWithArguments(parameters);
                            }
                        } catch (Throwable e) {
                            logger.error("Exception in command execution thread", e);
                        }
                    }, (async.threadingMode() != ThreadingMode.NONE)? async.threadingMode() : threading_mode);
                }



            } else {
                logger.trace("command segment is not final, looking for next segments");
                if (options == null) {
                    throw new IllegalArgumentException("SlashCommandData has no options");
                }
                for (var e : options) {
                    try {
                        logger.trace("recursively looking for next segment: {}", names[index + 1]);
                        findMethodAndExecute(names, index + 1, interaction, interaction_options.getOptionByName(e.name()).orElseThrow(), null, e);
                    } catch (NoSuchElementException n) {
                        // ignore
                    }
                }
            }
        }

    }

    private void findMethodAndAutocomplete(String[] names, int index, SlashCommandAutocompleteInteraction interaction, SlashCommandInteractionOptionProvider interaction_options, SlashCommandData command, SlashCommandOptionData<?> option) {

        String looking_for = names[index];

        logger.trace("looking for command segment for autocomplete: {}", looking_for);

        var focused_option = interaction.getTargetOption();

        String name;
        List<? extends SlashCommandOptionData<?>> options;
        if (command == null) {
            name = option.name();
            options = option.options();
        } else {
            name = command.name();
            options = command.options();
        }

        if (name.equals(looking_for)) {
            logger.trace("found command segment: {}", looking_for);
            if (index == names.length - 1) {
                logger.trace("found final command segment");

                for (var e : options) {
                    if (e.name().equals(focused_option.getName())) {
                        if (e.autocompletable_data() == null) {
                            throw new IllegalArgumentException("SlashCommandOptionData has no autocompletable data");
                        }
                        var autocompletable_data = e.autocompletable_data();
                        var method = autocompletable_data.method();
                        var instance = autocompletable_data.instance();

                        if (!methodmap.containsKey(method)) {
                            try {
                                logger.trace("unreflecting Method to MethodHandle: {}", method);
                                methodmap.put(method, MethodHandles.lookup().unreflect(method));
                            } catch (IllegalAccessException ex) {
                                throw new NoSuchElementException(ex);
                            }
                        }

                        var handle = Objects.requireNonNull(methodmap.get(method));

                        var parameters = new ArrayList<Object>();
                        if (!Modifier.isStatic(method.getModifiers())) {
                            logger.trace("Method is not static, adding instance to parameters");
                            parameters.add(Objects.requireNonNull(instance, "Instance not found for non-static method"));
                        }

                        var opt_value = focused_option.getValue();

                        var user_input = opt_value.orElseThrow();

                        for (var param : autocompletable_data.params()) {
                            parameters.add(switch (param) {
                                case INTERACTION -> interaction;
                                case IMPLEMENTATION_INTERACTION -> interaction.getImplementation();
                                case VALUE -> user_input;
                            });
                        }

                        final Async async = method.getDeclaredAnnotation(Async.class);

                        if (async == null) {
                            logger.trace("Method is not async, executing immediately");
                            try {
                                var result = handle.invokeWithArguments(parameters);
                                handleAutocompleteResult(result, autocompletable_data, interaction, user_input);
                            } catch (Throwable t) {
                                logger.error("Exception in autocomplete event listener thread: ", t);
                            }
                        } else {
                            logger.trace("Method is async, dispatching to thread");
                            dispatchThreaded(() -> {
                                try {
                                    var result = handle.invokeWithArguments(parameters);
                                    handleAutocompleteResult(result, autocompletable_data, interaction, user_input);
                                } catch (Throwable t) {
                                    logger.error("Exception in autocomplete thread: ", t);
                                }
                            }, (async.threadingMode() != ThreadingMode.NONE)? async.threadingMode() : threading_mode);
                        }
                    }
                }

            } else {
                logger.trace("command segment is not final, looking for next segments");
                if (options == null) {
                    throw new IllegalArgumentException("SlashCommandData has no options");
                }
                for (var e : options) {
                    try {
                        logger.trace("recursively looking for next segment: {}", names[index + 1]);
                        findMethodAndAutocomplete(names, index + 1, interaction, interaction_options.getOptionByName(e.name()).orElseThrow(), null, e);
                    } catch (NoSuchElementException n) {
                        // ignore
                    }
                }
            }
        }

    }

    @SuppressWarnings("unchecked")
    private void handleAutocompleteResult(Object returned, AutocompletableData data, SlashCommandAutocompleteInteraction interaction, Object user_input) {
        logger.debug("handling autocomplete result: {}", returned);
        var suggestions = (List<? extends AutocompleteSuggestion<?>>) returned;

        if (data.filter() != null) {
            suggestions = data.filter().filter(suggestions, user_input);
        }

        var list = new ArrayList<canaryprism.discordbridge.api.data.interaction.slash.SlashCommandOptionChoiceData>();

        for (var suggestion : suggestions) {
            list.add(new canaryprism.discordbridge.api.data.interaction.slash.SlashCommandOptionChoiceData(suggestion.name(), suggestion.value()));
        }

        interaction.suggest(list)
            .exceptionally(t -> {
                logger.error("Exception when submitting autocomplete response: ", t);
                return null;
            });
    }

    private volatile ThreadingMode threading_mode = ThreadingMode.PREFER_VIRTUAL;

    /**
     * <p>sets the default threading mode that is used when a command doesn't specify what mode to use itself</p>
     * <p>default value is {@link ThreadingMode#PREFER_VIRTUAL}
     * @param mode the mode to use
     */
    public void setDefaultThreadingMode(ThreadingMode mode) {
        if (mode == ThreadingMode.NONE) {
            throw new IllegalArgumentException("ThreadingMode.none is not allowed here");
        }
        if (mode == ThreadingMode.VIRTUAL && vthread_ex.isEmpty()) {
            throw new UnsupportedOperationException("No virtual thread support found for this JVM");
        }
        threading_mode = mode;
    }

    private static final ExecutorService osthread_ex = Executors.newCachedThreadPool();
    private static final ExecutorService daemonthread_ex = Executors.newCachedThreadPool((r) -> {
        var t = new Thread(r);
        t.setDaemon(true);
        return t;
    });
    private static final Optional<ExecutorService> vthread_ex;
    static {
        Optional<ExecutorService> handle = Optional.empty();
        try {
            logger.trace("checking for virtual thread support");

            @SuppressWarnings("JavaReflectionMemberAccess")
            var vthread_executor_getter = Class.forName("java.util.concurrent.Executors").getDeclaredMethod("newVirtualThreadPerTaskExecutor");
            handle = Optional.of((ExecutorService)vthread_executor_getter.invoke(null));

            logger.debug("Virtual thread support found for this JVM");
        } catch (Exception e) {
            logger.info("No virtual thread support found for this JVM");
        }
        vthread_ex = handle;
    }

    private static void dispatchThreaded(Runnable runnable, ThreadingMode mode) {
        var dispatcher = switch (mode) {
            case PLATFORM -> osthread_ex;
            case VIRTUAL -> vthread_ex.orElseThrow(() -> new UnsupportedOperationException("No virtual thread support found for this JVM"));
            case DAEMON -> daemonthread_ex;
            case PREFER_VIRTUAL -> vthread_ex.orElse(daemonthread_ex);
            case NONE -> throw new UnsupportedOperationException("ThreadingMode.none is not allowed here");
        };

        dispatcher.submit(runnable);
        logger.debug("Dispatched task to {}", dispatcher);
    }

    private String[] splitString(String text, int every) {
        logger.trace("splitting string '{}' into chunks of {}", text, every);
        List<String> results = new ArrayList<>();
        int length = text.length();

        for (int i = 0; i < length; i += every) {
            logger.trace("adding chunk from {} to {}", i, Math.min(length, i + every));
            results.add(text.substring(i, Math.min(length, i + every)));
        }

        return results.toArray(String[]::new);
    }

    private Optional<String> getReturnedResponse(Type return_type, Object returned) {
        logger.trace("parsing returned response '{}' to Optional<String>", returned);
        String text;

        if (return_type.equals(String.class)) {
            logger.trace("return type should be String");

            var str = (String) returned;
            if (str == null) {
                logger.trace("returned string is null, returning empty optional");
                return Optional.empty(); // we don't respond if the returned string is null
            }
            if (str.isBlank()) {
                /*
                 * if the returned string is blank, we don't respond
                 * this is because you can't even send a blank message to discord
                 * this is technically a valid way to not respond to a command
                 * but it's likely also a developer error
                 * because of this, we log a warning
                 */
                throw new IllegalArgumentException("""
                    Invalid return value for @ReturnsResponse. you may not return a blank String
                    if you want to not respond to the interaction, return null or an empty Optional<String> instead
                    """);
            }

            text = str;
        } else if (return_type.equals(OPTIONAL_OF_STRING)) {
            logger.trace("return type should be Optional<String>");

            var opt = (Optional<?>) returned;
            //noinspection OptionalAssignedToNull
            if (opt == null) {
                // an Optional implies a contract that it will never be null
                // this will not be treated as a valid value
                throw new IllegalArgumentException("Invalid return value for @ReturnsResponse. you may not return a null Optional");
            }
            if (opt.isEmpty()) {
                logger.trace("returned optional is empty, returning empty optional");
                return Optional.empty(); // we don't respond if the returned optional is empty
            }

            text = (String) opt.get();
        } else {
            throw new IllegalArgumentException("Invalid return type for @ReturnsResponse"); // this should never happen
        }

        return Optional.of(text);
    }

    private void processImmediateRespond(SlashCommandInteraction interaction, ReturnsResponse returns_response, Type return_type, Object returned) {

        var opt_text = getReturnedResponse(return_type, returned);
        if (opt_text.isEmpty()) {
            return;
        }
        
        var text = opt_text.get();

        logger.debug("processing immediate response of '{}'", text);
        var responder = interaction.createImmediateResponder();

        if (returns_response.ephemeral()) {
            logger.trace("setting response to ephemeral");
            responder.setFlags(MessageFlag.EPHEMERAL);
        }
        if (returns_response.silent()) {
            logger.trace("setting response to silent");
            responder.setFlags(MessageFlag.SILENT);
        }
        if (returns_response.splitOnLimit()) {
            logger.trace("splitting response on character limit");
            var split = splitString(text, 2000);
            responder.setContent(split[0]);
            responder.respond().join();

            var followup = interaction.createFollowupResponder();

            if (returns_response.ephemeral()) {
                followup.setFlags(MessageFlag.EPHEMERAL);
            }
            if (returns_response.silent()) {
                followup.setFlags(MessageFlag.SILENT);
            }

            for (int i = 1; i < split.length; i++) {
                followup.setContent(split[i]);
                followup.send().join();
            }

        } else {
            logger.trace("not splitting response on character limit");
            responder.setContent(text);
            responder.respond().join();
        }
    }

    private <T extends Annotation> T getAnnotationRecursive(Method method, Class<T> annotation_type) {
        logger.trace("trying to get annotation {} from method {}", annotation_type, method);
        if (method.getDeclaredAnnotation(annotation_type) != null) {
            logger.trace("found annotation {} on method", annotation_type);
            return method.getDeclaredAnnotation(annotation_type);
        }
        var enclosing = method.getDeclaringClass();
        var root = Commands.class;

        logger.trace("method doesn't have annotation {}, looking from enclosing class {}", annotation_type, enclosing);
        //noinspection ConstantValue silly intellij
        while (enclosing != null && !root.isInstance(enclosing)) {
            if (enclosing.getDeclaredAnnotation(annotation_type) != null) {
                logger.trace("found annotation {} on class {}", annotation_type, enclosing);
                return enclosing.getDeclaredAnnotation(annotation_type);
            }
            enclosing = enclosing.getEnclosingClass();
            logger.trace("class doesn't have annotation {}, looking from enclosing class {}", annotation_type, enclosing);
        }
        logger.trace("no annotation {} found", annotation_type);
        return null;
    }

    /**
     * <p>unregisters the event listener</p>
     * <p>once you call this method there is no way to reactivate the event listener of this instance ever again</p>
     * <p>this also technically doesn't stop you from registering more commands after you call it, the listener just won't work obviously</p>
     */
    public void stop() {
        api.removeListener(listener);
        api.removeListener(autocomplete_listener);
        logger.info("Stopped CommandHandler event listeners");
    }

    /**
     * <p>Registers a {@link Commands} <em>class</em> to be parsed by the {@link CommandHandler}</p>
     * <p>if any of the commands are in instance methods, you must use {@link #register(Commands, boolean)} and pass an instance instead</p>
     * <p>
     * if the class could be parsed successfully, the commands that were parsed will take effect 
     * and be registered with Discord. if not, this will throw a {@link ParsingException}
     * </p>
     * 
     * <p>
     * if overwrites is true, all previous commands registered by the bot <b>will be deleted from discord</b>. 
     * yes, even the ones previously registered to this command handler.
     * </p>
     * <p>
     * if overwrites is false, the command handler will attempt to get the existing commands from discord, and merge them with the new commands.
     * </p>
     * 
     * @param target the Class object of the Commands class to parse, must not be null
     * @param overwrites whether or not to overwrite existing commands
     */
    public void register(Class<? extends Commands> target, boolean overwrites) {
        logger.debug("registering Commands class with Class object");
        this.register(null, target, overwrites);
    }

    /**
     * <p>Registers a {@link Commands} <em>instance</em> to be parsed by the {@link CommandHandler}</p>
     * <p>if all of the commands are in static methods, consider using {@link #register(Class, boolean)} and pass the Class object instead</p>
     * <p>
     * if the class of the instance could be parsed successfully, the commands that were parsed will take effect 
     * and be registered with Discord. if not, this will throw a {@link ParsingException}
     * </p>
     * 
     * <p>
     * if overwrites is true, all previous commands registered by the bot <b>will be deleted from discord</b>. 
     * yes, even the ones previously registered to this command handler.
     * </p>
     * <p>
     * if overwrites is false, the command handler will attempt to get the existing commands from discord, and merge them with the new commands.
     * </p>
     * 
     * @param target_instance the instance of the Commands class to parse, must not be null
     * @param overwrites whether or not to overwrite existing commands
     */
    public void register(Commands target_instance, boolean overwrites) {
        logger.debug("registering Commands class with instance");
        // technically this null check is not needed because we access the getClass() method on the exact same line but it's here for clarity
        this.register(Objects.requireNonNull(target_instance, "Commands instance cannot be null"), target_instance.getClass(), overwrites);
    }

    @SuppressWarnings("java:S127")
    private void register(Commands target_instance, Class<? extends Commands> target, boolean overwrites) {
        logger.debug("registering commands from class {}, overwriting set to {}", target, false);
        server_id = -1;

        var new_commands = new ArrayList<SlashCommandData>();
        parseFromClass(target_instance, target, 0, new_commands);

        //yell about duplicate names
        logger.trace("checking for duplicate command names");
        for (int i = 0; i < new_commands.size(); i++) {
            for (int j = i + 1; j < new_commands.size(); j++) {
                if (new_commands.get(i).name().equals(new_commands.get(j).name()) && new_commands.get(i).server_id() == new_commands.get(j).server_id()) {
                    throw new ParsingException(
                        "Duplicate command name /" + new_commands.get(i).name(), 
                        "at class " + target.getName()
                    );
                }
            }
        }

        var processed_commands = new ArrayList<SlashCommandData>();


        var to_add = new ArrayList<SlashCommandData>();
        if (server_id == 0) {
            logger.trace("registering to global commands");
            
            if (!overwrites) {
                logger.debug("getting existing global commands from discord");
                to_add.addAll(api.getGlobalSlashCommands().join().stream().map(this::parseFromSlashCommand).toList());

                var new_command_names = new_commands.stream().map(SlashCommandData::name).collect(Collectors.toSet());

                // override old commands with new ones if they're the same name
                var it = to_add.listIterator();
                while (it.hasNext()) {
                    var command = it.next();
                    if (new_command_names.contains(command.name())) {
                        it.remove();
                        logger.info("overwriting old command {} retrieved from discord with new command", command);
                    }
                }
            }
            to_add.addAll(new_commands);
            api.bulkUpdateGlobalCommands(to_add.stream().map(SlashCommandData::toSlashCommandBuilder).collect(Collectors.toSet())).join();
            logger.trace("bulkOverwriteGlobalApplicationCommands finished");
            processed_commands.addAll(new_commands);
        } else {
            var server = api.getServerById(server_id)
                    .orElseThrow(() -> new ParsingException(
                            "couldn't find server with ID " + server_id, "at class " + target.getName()));
            if (!overwrites) {
                logger.debug("getting existing server commands from discord");
                to_add.addAll(
                        server.getServerSlashCommands()
                                .join()
                                .stream()
                                .map(this::parseFromSlashCommand)
                                .toList()
                );

                var new_command_names = new_commands.stream().map(SlashCommandData::name).collect(Collectors.toSet());

                // override old commands with new ones if they're the same name
                var it = to_add.listIterator();
                while (it.hasNext()) {
                    var command = it.next();
                    if (new_command_names.contains(command.name())) {
                        it.remove();
                        logger.info("overwriting old command {} retrieved from discord with new command", command);
                    }
                }

            }
            to_add.addAll(new_commands);
            server.bulkUpdateServerCommands(to_add.stream()
                            .map(SlashCommandData::toSlashCommandBuilder)
                            .collect(Collectors.toSet()))
                    .join();
            logger.trace("bulkOverwriteServerApplicationCommands finished");
            processed_commands.addAll(new_commands);
        }

        synchronized (commands) {
            if (!overwrites) {
                logger.debug("overwrite set to false, merging new commands with existing commands in memory while overwriting ones with the same name and server id");
                for (var processed_command : processed_commands) {
                    for (int i = 0; i < commands.size(); i++) {
                        if (processed_command.name().equals(commands.get(i).name())
                                && processed_command.server_id() == commands.get(i).server_id()
                                && !processed_command.equals(commands.get(i))) {
                            logger.trace("replacing old command {} from memory with new command {}",
                                commands.get(i)::toString, processed_command::toString);
                            commands.remove(i--);
                        }
                    }
                }
            } else {
                logger.debug("overwrite set to true, removing all older commands with the same server id from memory");
                for (int i = 0; i < commands.size(); i++) {
                    if (commands.get(i).server_id() == server_id) {
                        logger.trace("removing old command {} from memory", commands.get(i)::toString);
                        commands.remove(i--);
                    }
                }
            }

            commands.addAll(processed_commands);
        }

        logger.debug("registration of commands finished. added {} commands to discord from class {}", processed_commands.size(), target);
    }

    private long server_id;

    private static final MethodHandle custom_name_getter;
    static {
        try {
            logger.trace("obtaining getter method handle for CustomChoiceName::getCustomName");
            custom_name_getter = MethodHandles.lookup().findVirtual(CustomChoiceName.class, "getCustomName", MethodType.methodType(String.class));
        } catch (Exception e) {
            throw new NoSuchElementException(e); // this should never happen
        }
    }

    private static final MethodHandle custom_name_translations_getter;
    static {
        try {
            logger.trace("obtaining getter method handle for CustomChoiceName::getCustomNameTranslations");
            custom_name_translations_getter = MethodHandles.lookup().findVirtual(CustomChoiceName.class, "getCustomNameTranslations", MethodType.methodType(Map.class));
        } catch (Exception e) {
            throw new NoSuchElementException(e); // this should never happen
        }
    }

    private static final ParameterizedType OPTIONAL_OF_STRING = new ParameterizedType() {
        @NotNull
        @Contract(value = " -> new", pure = true)
        @Override
        public Type @NotNull [] getActualTypeArguments() {
            return new Type[] { String.class };
        }
        @NotNull
        @Contract(value = " -> new", pure = true)
        @Override
        public Type getRawType() {
            return Optional.class;
        }
        @Override
        public Type getOwnerType() {
            return null;
        }
    };

    @SuppressWarnings({"unchecked", "java:S3011", "DuplicateExpressions"})
    private void parseFromClass(Object instance, Class<?> target, int depth, ArrayList<? extends Data> target_list) {
        logger.debug("parsing from class {} with instance {} at depth {}", target, instance, depth);

        if (depth > 2) {
            throw new ParsingException("you are not allowed to nest commands more than 2 levels deep", "at class " + target.getName());
        }

        if (target.getMethods().length + target.getDeclaredClasses().length == 0 && depth != 0) {
            throw new ParsingException("you are not allowed to have an empty command group", "at class " + target.getName());
        }

        var create_global = target.getDeclaredAnnotation(CreateGlobal.class);
        var create_server = target.getDeclaredAnnotation(CreateServer.class);
        if (create_global != null && create_server != null) {
            throw new ParsingException("you are not allowed to use both @CreateGlobal and @CreateServer", "at class " + target.getName());
        }
        if (create_global != null) {
            if (depth != 0) {
                throw new ParsingException("you are not allowed to use @CreateGlobal on a command group", "at class " + target.getName());
            }
            server_id = 0;
        }
        if (create_server != null) {
            if (depth != 0) {
                throw new ParsingException("you are not allowed to use @CreateServer on a command group", "at class " + target.getName());
            }
            server_id = create_server.value();
        }
        if (create_global == null && create_server == null && depth == 0) {
            throw new ParsingException("a root Commandable requires either @CreateGlobal or @CreateServer", "at class " + target.getName());
        }


        try {
            logger.trace("parsing through methods");
            for (var method : target.getDeclaredMethods()) {
                logger.trace("parsing method {}", method);
                var command = method.getDeclaredAnnotation(Command.class);
                if (command == null) continue;

                if (instance == null && !Modifier.isStatic(method.getModifiers())) {
                    throw new ParsingException("Command method must be static if no instance of Commandable is provided", "in method " + target.getName() + "." + method.getName());
                }

                method.setAccessible(true);

                ReturnsResponse returns_response = method.getDeclaredAnnotation(ReturnsResponse.class);
                if (returns_response != null) {
                    logger.trace("found @ReturnsResponse on method");
                    if (method.getReturnType() != String.class
                        && !method.getGenericReturnType().equals(OPTIONAL_OF_STRING))
                        throw new ParsingException("Method with @ReturnsResponse must return a String or Optional<String>", "in method " + target.getName() + "." + method.getName());

                    if (returns_response.ephemeral() && returns_response.silent())
                        throw new ParsingException("@ReturnsResponse cannot have both ephemeral and silent set to true", "in method " + target.getName() + "." + method.getName());
                }

                var async = getAnnotationRecursive(method, Async.class);
                if (async != null) {
                    logger.trace("found @Async on method");

                    if (vthread_ex.isEmpty() && async.threadingMode() == ThreadingMode.VIRTUAL)
                        throw new ParsingException("Virtual threads are not supported on this JVM", "in method " + target.getName() + "." + method.getName());
                }

                var name = command.name();
                var description = command.description();

                var localizations = parseLocalizationData(method.getDeclaredAnnotationsByType(Trans.class),
                        "in method " + target.getName() + "." + method.getName());

                boolean skip_next_interaction_parameter = false;
                boolean requires_interaction = false;
                var interaction_uses_implementation_type = false;
                try {
                    if (method.getParameters()[0].getDeclaredAnnotation(Interaction.class) != null) {
                        logger.trace("found @Interaction on first parameter");
                        skip_next_interaction_parameter = true;
                        requires_interaction = true;
                        if (method.getParameters()[0].getType() != SlashCommandInteraction.class) {
                            if (bridge.getImplementationType(SlashCommandInteraction.class)
                                    .map(method.getParameters()[0].getType()::equals)
                                    .orElse(false))
                                interaction_uses_implementation_type = true;
                            else
                                throw new ParsingException(String.format(
                                        "@Interaction can only be applied to the first parameter with type canaryprism.discordbridge.api.interaction.slash.SlashCommandInteraction or %s",
                                        bridge.getImplementationType(SlashCommandInteraction.class)
                                                .map(Class::getName)
                                                .orElse("<not found>")),
                                        "with parameter " + target.getName() + "." + method.getName() + "(" + method.getParameters()[0].getType().getSimpleName() + " " + method.getParameters()[0].getName() + ")");
                        }
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    logger.trace("no parameters found for method");
                }

                ArrayList<SlashCommandOptionData<?>> options = new ArrayList<>();
                try {
                    logger.trace("parsing through parameters");
                    for (var parameter : method.getParameters()) {
                        logger.trace("parsing parameter {}", parameter);
                        if (parameter.getAnnotation(Interaction.class) != null) {
                            if (skip_next_interaction_parameter) {
                                logger.trace("skipping @Interaction parameter");
                                skip_next_interaction_parameter = false;
                                continue;
                            }
                            throw new ParsingException(String.format(
                                    "@Interaction can only be applied to the first parameter with type canaryprism.discordbridge.api.interaction.slash.SlashCommandInteraction or %s",
                                    bridge.getImplementationType(SlashCommandInteraction.class)
                                            .map(Class::getName)
                                            .orElse("<not found>")),
                                    "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");

                        }

                        var option = parameter.getDeclaredAnnotation(Option.class);
                        if (option == null) 
                            throw new ParsingException("All parameters must have either @Interaction or @Option", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");

                        logger.trace("found @Option on parameter");


                        var parameter_type = parameter.getParameterizedType();
                        var unwrapped_type = parameter_type;
                        if (parameter_type instanceof ParameterizedType pt && pt.getRawType().equals(Optional.class)) {
                            unwrapped_type = pt.getActualTypeArguments()[0];
                            logger.trace("parameter type {} is Optional, unwrapped to {}", parameter_type, unwrapped_type);
                        }

                        var actual_type = unwrapped_type;
                        if (unwrapped_type instanceof Class<?> c && ServerChannel.class.isAssignableFrom(c)) {
                            actual_type = ServerChannel.class;
                            logger.trace("parameter type {} is subtype of ServerChannel, simplifying to ServerChannel for option type parsing", unwrapped_type);
                        }

                        var is_enum = actual_type instanceof Class<?> c && c.isEnum();

                        SlashCommandOptionType option_type;
                        boolean uses_implementation_type;
                        if (is_enum) {
                            option_type = SlashCommandOptionType.INTEGER;
                            uses_implementation_type = false;
                        } else {
                            var final_actual_type = actual_type;
                            var inference = inferType(actual_type)
                                    .orElseThrow(() ->
                                            new ParsingException(
                                                    "Invalid parameter type '" + final_actual_type.getTypeName() + "', only types supported by the Discord Bridge api or " + bridge + " can be used",
                                                    "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")"));

                            option_type = inference.type;
                            uses_implementation_type = inference.uses_implementation_type;
                        }

                        var option_name = option.name();
                        var option_description = option.description();

                        if (option_description.isEmpty()) {
                            logger.trace("description is blank, using name '{}' as description", option_name);
                            option_description = option_name;
                        }

                        var option_localizations = parseLocalizationData(parameter.getDeclaredAnnotationsByType(Trans.class),
                                "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");

                        var option_required = !(parameter_type instanceof ParameterizedType pt && pt.getRawType().equals(Optional.class));
                        var option_string_choices = option.stringChoices();
                        var option_long_choices = option.longChoices();

                        OptionBoundsData bounds_data = null;

                        EnumSet<ChannelType> inferred_channel_bounds = null;
                        if (option_type == SlashCommandOptionType.CHANNEL) {
                            inferred_channel_bounds = inferChannelTypeBounds(actual_type);
                            logger.trace("inferred channel type bounds for parameter type {}: {}", actual_type, inferred_channel_bounds);

                            bounds_data = new ChannelTypeBoundsData(inferred_channel_bounds);
                        }

                        var channel_type_bounds = parameter.getDeclaredAnnotation(ChannelTypeBounds.class);
                        if (channel_type_bounds != null) {
                            logger.trace("found @ChannelTypeBounds on parameter");
                            if (option_type != SlashCommandOptionType.CHANNEL) {
                                throw new ParsingException("ChannelTypeBounds can only be applied to Channel parameters", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }

                            var channel_types_arr = channel_type_bounds.value();
                            var channel_types = EnumSet.noneOf(ChannelType.class);
                            for (var type : channel_types_arr) {
                                var success = channel_types.add(type);
                                if (!success) {
                                    logger.warn("""
                                            Duplicate Channel bound types found {} with parameter {}.{}({} {}) !!
                                            ignoring duplicate
                                            """, () -> type, target::getName, method::getName, parameter.getType()::getSimpleName, parameter::getName);
                                }
                            }

                            if (!inferred_channel_bounds.containsAll(channel_types)) {
                                throw new ParsingException("@ChannelTypeBounds allows channel types that aren't assignable to the parameter type " + actual_type, "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }

                            if (channel_types.isEmpty()) {
                                throw new ParsingException("empty ChannelTypeBounds not allowed", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }

                            bounds_data = new ChannelTypeBoundsData(channel_types);
                        }

                        var double_bounds = parameter.getDeclaredAnnotation(DoubleBounds.class);
                        if (double_bounds != null) {
                            logger.trace("found @DoubleBounds on parameter");
                            if (option_type != SlashCommandOptionType.NUMBER) {
                                throw new ParsingException("@DoubleBounds can only be applied to double parameters", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }

                            var min = double_bounds.min();
                            var max = double_bounds.max();

                            if (min > max) {
                                throw new ParsingException("DoubleBounds min must be less than or equal to max", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }

                            if ((min == BOUNDS_MIN || min == Double.NEGATIVE_INFINITY)
                                && (max == BOUNDS_MAX || max == Double.POSITIVE_INFINITY)) {
                                logger.warn("""
                                        DoubleBounds has no effect
                                            with parameter {}.{}({} {})
                                        """, target::getName, method::getName, parameter_type::toString, parameter::getName);
                            } else if (min != Double.NEGATIVE_INFINITY && min < BOUNDS_MIN) {
                                throw new ParsingException("DoubleBounds min must not be smaller than -2^53", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            } else if (max != Double.POSITIVE_INFINITY && max > BOUNDS_MAX) {
                                throw new ParsingException("DoubleBounds max must not be greater than 2^53", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }

                            bounds_data = new DoubleBoundsData(min, max);
                        }

                        var long_bounds = parameter.getDeclaredAnnotation(LongBounds.class);
                        if (long_bounds != null) {
                            logger.trace("found @LongBounds on parameter");
                            if (option_type != SlashCommandOptionType.INTEGER) {
                                throw new ParsingException("@LongBounds can only be applied to long parameters", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }

                            var min = long_bounds.min();
                            var max = long_bounds.max();

                            if (min > max) {
                                throw new ParsingException("LongBounds min must be less than or equal to max", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }

                            if ((min == BOUNDS_MIN || min == Long.MIN_VALUE)
                                && (max == BOUNDS_MAX || max == Long.MAX_VALUE)) {
                                logger.warn("""
                                        LongBounds has no effect
                                            with parameter {}.{}({} {})
                                        """, target::getName, method::getName, parameter_type::toString, parameter::getName);
                            } else if (min != Long.MIN_VALUE && min < BOUNDS_MIN) {
                                throw new ParsingException("LongBounds min must not be smaller than -2^53", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            } else if (max != Long.MAX_VALUE && max > BOUNDS_MAX) {
                                throw new ParsingException("LongBounds max must not be greater than 2^53", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }

                            bounds_data = new LongBoundsData(min, max);
                        }

                        var string_length_bounds = parameter.getDeclaredAnnotation(StringLengthBounds.class);
                        if (string_length_bounds != null) {
                            logger.trace("found @StringLengthBounds on parameter");
                            if (option_type != SlashCommandOptionType.STRING) {
                                throw new ParsingException("@StringLengthBounds can only be applied to String parameters", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }

                            var min = string_length_bounds.min();
                            var max = string_length_bounds.max();

                            if (min > max) {
                                throw new ParsingException("StringLengthBounds min must be less than or equal to max", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }

                            if (min < 0) {
                                throw new ParsingException("StringLengthBounds min must not be negative", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }

                            if (min == 0 && max == Long.MAX_VALUE) {
                                logger.warn("""
                                        StringLengthBounds has no effect
                                            with parameter {}.{}({} {})
                                        """, target::getName, method::getName, parameter_type::toString, parameter::getName);
                            }

                            bounds_data = new StringLengthBoundsData(min, max);
                        }

                        var autocomplete = parameter.getDeclaredAnnotation(Autocompletes.class);
                        if (autocomplete != null) {
                            logger.trace("found @Autocompletes on parameter");
                            if (actual_type != String.class && actual_type != Long.class && actual_type != long.class)
                                throw new ParsingException("Autocomplete can only be applied to String or long", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            var actual_class = (Class<?>)actual_type;

                            if (option_string_choices.length > 0 || option_long_choices.length > 0)
                                throw new ParsingException("Autocomplete cannot be used with choices", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            try {
                                var supplier_class = autocomplete.autocompleterClass();
                                if (supplier_class == Void.class) {
                                    supplier_class = target;
                                }
                                var supplier_class_is_target = (supplier_class == target);
                                var supplier_method_name = autocomplete.autocompleter();

                                try {
                                    logger.debug("attempting to resolve autocomplete supplier method for parameter {}.{}({} {})", target::getName, method::getName, parameter_type::toString, parameter::getName);

                                    var autocompleter = obtainAutocompleterMethod(supplier_class, supplier_method_name, actual_class);

                                    var supplier_method = autocompleter.method();
                                    var params = autocompleter.param();

                                    validateAutocompleteSupplierMethod(supplier_method, actual_class);

                                    var final_actual_type = actual_type;
                                    var type = inferType(actual_class)
                                            .map(TypeInference::type) // ignore the internal type bc choices don't use any types that have an internal variant
                                            .filter((e) -> e.can_be_choices)
                                            .orElseThrow(() -> new ParsingException(
                                                    "Invalid parameter type '" + final_actual_type.getTypeName() + "', only autocompletable types supported by the Discord Bridge api or " + bridge + " can be used",
                                                    "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")"));

                                    AutocompleteFilter filter = null;

                                    var search_suggestions = supplier_method.getDeclaredAnnotation(SearchSuggestions.class);
                                    if (search_suggestions != null) {
                                        logger.trace("found SearchSuggestions in autocompleter method");

                                        filter = new AutocompleteFilterData(
                                            search_suggestions.at(),
                                            search_suggestions.containedIn(),
                                            search_suggestions.ignoreCase(),
                                            search_suggestions.ignoreWhitespace(),
                                            search_suggestions.ignorePunctuation(),
                                            search_suggestions.pruneToLimit(),
                                            search_suggestions.removeDuplicates(),
                                            search_suggestions.contiguous()
                                        );
                                    }

                                    AutocompletableData data;
                                    if (supplier_class_is_target) {
                                        logger.trace("autocompleter method is in the same class as the command method, nonstatic methods are allowed");
                                        if (Modifier.isStatic(supplier_method.getModifiers())) {
                                            data = new AutocompletableData(supplier_method, null, type, params, filter);
                                        } else {
                                            data = new AutocompletableData(supplier_method, instance, type, params, filter);
                                        }
                                    } else {
                                        logger.trace("autocompleter method is not in the same class as the command method, autocompleter method must be static");
                                        if (!Modifier.isStatic(supplier_method.getModifiers())) {
                                            throw new ParsingException("Autocomplete supplier method must be static if not in the same class", "in method " + supplier_class.getName() + "." + supplier_method_name + "(" + actual_class.getSimpleName() + ")");
                                        }
                                        data = new AutocompletableData(supplier_method, null, type, params, filter);
                                    }

                                    supplier_method.setAccessible(true);

                                    options.add(new SlashCommandOptionData<String>(
                                        option_name,
                                        option_description,
                                        option_localizations,
                                        option_required,
                                        option_type,
                                        uses_implementation_type,
                                        null,
                                        null,
                                        data,
                                        null,
                                        null,
                                        false,
                                        false,
                                        false,
                                        bounds_data
                                    ));


                                } catch (NoSuchMethodException | SecurityException e) {
                                    throw new ParsingException("Autocompleter method not found, an Autocompleter method can only take the parameters (" + actual_class.getSimpleName() + ") or (AutocompleteInteraction, " + actual_class.getSimpleName() + ")", "at class " + supplier_class.getName(), e);
                                } catch (ParsingException e) {
                                    throw e.addParseTrace("at class " + supplier_class.getName());
                                }
                            } catch (ParsingException e) {
                                throw e.addParseTrace("with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }
                        } else if (option_string_choices.length > 0) {
                            logger.trace("found string choices on parameter");
                            var optionchoices = new ArrayList<SlashCommandOptionChoiceData<String>>();
                            if (option_type != SlashCommandOptionType.STRING) {
                                throw new ParsingException("Option Choices type does not match parameter", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }
                            if (bounds_data != null) {
                                throw new ParsingException("Option Choices cannot be used when bounds are present", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }
                            for (var choice : option_string_choices) {
                                optionchoices.add(new SlashCommandOptionChoiceData<String>(
                                    choice.name().isEmpty()? choice.value() : choice.name(),
                                    choice.value(),
                                    parseOptionChoiceTranslations(choice.translations(), "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")")
                                ));
                            }
                            options.add(new SlashCommandOptionData<String>(
                                option_name, 
                                option_description, 
                                option_localizations,
                                option_required,
                                option_type,
                                uses_implementation_type,
                                null, 
                                optionchoices, 
                                null,
                                null,
                                null,
                                false,
                                false,
                                false,
                                null
                            ));

                        } else if (option_long_choices.length > 0) {
                            logger.trace("found long choices on parameter");
                            var optionchoices = new ArrayList<SlashCommandOptionChoiceData<Long>>();
                            if (option_type != SlashCommandOptionType.INTEGER) {
                                throw new ParsingException("Invalid option choice type at parameter " + parameter.getName() + " in method " + method.getName(), "at class " + target.getName());
                            }
                            if (bounds_data != null) {
                                throw new ParsingException("Option Choices cannot be used when bounds are present", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }
                            for (var choice : option_long_choices) {
                                optionchoices.add(new SlashCommandOptionChoiceData<Long>(
                                    choice.name(),
                                    choice.value(),
                                    parseOptionChoiceTranslations(choice.translations(), "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")")
                                ));
                            }
                            options.add(new SlashCommandOptionData<Long>(
                                option_name, 
                                option_description, 
                                option_localizations,
                                option_required,
                                option_type,
                                uses_implementation_type,
                                null, 
                                optionchoices, 
                                null,
                                null,
                                null,
                                false,
                                false,
                                false,
                                null
                            ));

                        } else if (is_enum) {
                            logger.trace("parameter type is enum");
                            var inner_class = (Class<?>)actual_type;
                            var optionchoices = new ArrayList<SlashCommandOptionChoiceData<Enum<?>>>();
                            if (option_type != SlashCommandOptionType.INTEGER) {
                                throw new ParsingException("Invalid option choice type at parameter " + parameter.getName() + " in method " + method.getName(), "at class " + target.getName());
                            }
                            if (long_bounds != null) {
                                throw new ParsingException("Option Choices cannot be used when bounds are present", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }
                            if (CustomChoiceName.class.isAssignableFrom(inner_class)) {
                                logger.trace("enum class implements CustomChoiceName");
                                for (var choice : inner_class.getEnumConstants()) {
                                    logger.trace("adding option choice {}", choice);
                                    try {
                                        var choicename = custom_name_getter.invoke(choice).toString();
                                        logger.trace("returned custom name is {}", choicename);
                                        if (choicename.isBlank()) {
                                            throw new ParsingException("CustomChoiceName.getCustomName() must return a non-blank string", "at class " + target.getName());
                                        }
                                        if (choicename.length() > 25) {
                                            throw new ParsingException("CustomChoiceName.getCustomName() must return a string with a length of 25 characters or less", "at class " + target.getName());
                                        }
                                        var choice_localizations = Map.copyOf((Map<DiscordLocale, String>)custom_name_translations_getter.invoke(choice));
                                        optionchoices.add(new SlashCommandOptionChoiceData<Enum<?>>(choicename, ((Enum<?>)choice), choice_localizations));
                                    } catch (Throwable e) {
                                        throw new ParsingException("Exception while trying to get custom name", "at class " + target.getName(), e);
                                    }
                                }
                            } else {
                                logger.trace("enum class does not implement CustomChoiceName");
                                for (var choice : inner_class.getEnumConstants()) {
                                    logger.trace("adding option choice {}", choice);
                                    optionchoices.add(new SlashCommandOptionChoiceData<Enum<?>>(choice.toString().replaceAll("(?<=.{25}).", ""), ((Enum<?>)choice), Map.of()));
                                }
                            }
                            options.add(new SlashCommandOptionData<Enum<?>>(
                                option_name, 
                                option_description, 
                                option_localizations,
                                option_required,
                                option_type,
                                uses_implementation_type,
                                null, 
                                optionchoices, 
                                null,
                                null,
                                null,
                                false,
                                false,
                                true,
                                null
                            ));

                        } else {
                            logger.trace("parameter is a simple option");
                            options.add(new SlashCommandOptionData<Long>(
                                option_name, 
                                option_description, 
                                option_localizations,
                                option_required,
                                option_type,
                                uses_implementation_type,
                                null,
                                null,
                                null, 
                                null,
                                null,
                                false,
                                false,
                                false,
                                bounds_data
                            ));
                        }
                    }
                } catch (ParsingException e) {
                    throw e.addParseTrace("in method " + target.getName() + "." + method.getName());
                }
                if (depth == 0) {
                    logger.trace("depth is 0, adding command method as a SlashCommand");

                    var requires_permissions = method.getDeclaredAnnotation(RequiresPermissions.class);
                    HashSet<PermissionType> permissions = null;
                    if (requires_permissions != null) {
                        logger.trace("found @RequiresPermissions on method");
                        permissions = new HashSet<>();
                        for (var e : requires_permissions.value()) {
                            var success = permissions.add(e);
                            if (!success) {
                                logger.warn("""
                                        Duplicate required permissions found {} in method {}.{} !!
                                        ignoring duplicate
                                        """, e, target.getName(), method.getName());
                            }
                        }
                    }
                    if (permissions != null && permissions.isEmpty()) {
                        logger.info("""
                                Empty required permissions list at method {}.{}
                                Discord will interpret this as requiring PermissionType.ADMINISTRATOR
                                """, target.getName(), method.getName());
                    }
                    ((ArrayList<SlashCommandData>) target_list).add(new SlashCommandData(
                            name,
                            description,
                            localizations,
                            (server_id == 0) && command.enabledInDMs(),
                            command.nsfw(),
                            Optional.ofNullable(permissions).map((e) -> (e.isEmpty()) ? EnumSet.noneOf(PermissionType.class) : EnumSet.copyOf(e)).orElse(null),
                            server_id,
                            options,
                            method,
                            instance,
                            requires_interaction,
                            interaction_uses_implementation_type
                    ));
                } else {
                    logger.trace("depth is not 0, adding command method as a SlashCommandOption with type SUB_COMMAND or SUB_COMMAND_GROUP");

                    if (method.getDeclaredAnnotation(RequiresPermissions.class) != null) {
                        logger.trace("found @RequiresPermissions on method");
                        // not allowed here
                        throw new ParsingException("@RequiresPermissions is not allowed in nested commands or command groups", 
                            "in method " + target.getName() + "." + method.getName());
                    }
                    if (!command.enabledInDMs()) {
                        throw new ParsingException("enabledInDMs = false is not allowed in nested commands or command groups",
                            "in method " + target.getName() + "." + method.getName());
                    }
                    ((ArrayList<SlashCommandOptionData<?>>) target_list).add(new SlashCommandOptionData<Long>(
                            name,
                            description,
                            localizations,
                            false,
                            SlashCommandOptionType.SUBCOMMAND,
                            false,
                            options,
                            null,
                            null,
                            method,
                            instance,
                            requires_interaction,
                            interaction_uses_implementation_type,
                            false,
                            null
                    ));
                }

            }
            logger.trace("parsing through nested classes");
            for (var group : target.getDeclaredClasses()) {
                logger.trace("parsing nested class {}", group);

                var group_of_commands = group.getDeclaredAnnotation(CommandGroup.class);
                if (group_of_commands == null) continue;

                var name = group_of_commands.name();
                var description = group_of_commands.description();

                var localizations = parseLocalizationData(group.getDeclaredAnnotationsByType(Trans.class),
                        "at class " + target.getName());

                if (description.isEmpty()) {
                    logger.trace("description is blank, using name '{}' as description", name);
                    description = name;
                }

                ArrayList<SlashCommandOptionData<?>> options = new ArrayList<>();

                Object group_instance;
                if (instance == null) {
                    group_instance = null;
                } else {
                    logger.trace("attempting to instantiate nested class");
                    if (Modifier.isStatic(group.getModifiers())) {
                        logger.trace("nested class is static");
                        try {
                            var constructor = group.getDeclaredConstructor();
                            constructor.setAccessible(true);
                            group_instance = constructor.newInstance();
                        } catch (NoSuchMethodException e) {
                            throw new ParsingException("CommandGroup class must have a no-args constructor", "at class " + group.getName());
                        } catch (Exception e) {
                            throw new ParsingException("Exception while trying to instantiate class", "at class " + group.getName(), e);
                        }
                    } else {
                        logger.trace("nested class is not static (inner class)");
                        try {
                            var constructor = group.getDeclaredConstructor(target);
                            constructor.setAccessible(true);
                            group_instance = constructor.newInstance(instance);
                        } catch (NoSuchMethodException e) {
                            throw new ParsingException("CommandGroup class must have a no-args constructor", "at class " + group.getName());
                        } catch (Exception e) {
                            throw new ParsingException("Exception while trying to instantiate class", "at class " + group.getName(), e);
                        }
                    }
                }


                logger.trace("recursively parsing from nested class");
                
                parseFromClass(group_instance, group, depth + 1, options);

                if (depth == 0) {
                    logger.trace("depth is 0, adding command group as a SlashCommand");
                    var requires_permissions = group.getDeclaredAnnotation(RequiresPermissions.class);
                    HashSet<PermissionType> permissions = null;
                    if (requires_permissions != null) {
                        logger.trace("found @RequiresPermissions on class");
                        permissions = new HashSet<>();
                        for (var e : requires_permissions.value()) {
                            var success = permissions.add(e);
                            if (!success) {
                                logger.warn("""
                                        Duplicate required permissions found {} at class {} !!
                                        ignoring duplicate
                                        """, e, group.getName());
                            }
                        }
                    }
                    if (permissions != null && permissions.isEmpty()) {
                        logger.info("""
                            Empty required permissions list at class {}
                            Discord will interpret this as requiring PermissionType.ADMINISTRATOR
                            """, group.getName());
                    }
                    ((ArrayList<SlashCommandData>) target_list).add(new SlashCommandData(
                            name,
                            description,
                            localizations,
                            (server_id == 0) && group_of_commands.enabledInDMs(),
                            group_of_commands.nsfw(),
                            Optional.ofNullable(permissions).map((e) -> (e.isEmpty()) ? EnumSet.noneOf(PermissionType.class) : EnumSet.copyOf(e)).orElse(null),
                            server_id,
                            options,
                            null,
                            null,
                            true,
                            false
                    ));
                } else {
                    logger.trace("depth is not 0, adding command group as a SlashCommandOption with type SUB_COMMAND_GROUP");
                    if (group.getDeclaredAnnotation(RequiresPermissions.class) != null) {
                        logger.trace("found @RequiresPermissions on class");
                        // not allowed here
                        throw new ParsingException(
                                "@RequiresPermissions is not allowed in nested commands or command groups",
                                "at class " + group.getName());
                    }
                    if (!group_of_commands.enabledInDMs()) {
                        throw new ParsingException(
                                "enabledInDMs = false is not allowed in nested commands or command groups",
                                "at class " + group.getName());
                    }
                    ((ArrayList<SlashCommandOptionData<?>>) target_list).add(new SlashCommandOptionData<Long>(
                        name, 
                        description, 
                        localizations,
                        false,
                        SlashCommandOptionType.SUBCOMMAND_GROUP,
                        false,
                        options, 
                        null,
                        null,
                        null,
                        null,
                        true,
                        false,
                        false,
                        null
                    ));
                }
            }
        } catch (ParsingException e) {
            throw e.addParseTrace("at class " + target.getName());
        }
    }

    record TypeInference(SlashCommandOptionType type, boolean uses_implementation_type) {}

    private Optional<? extends TypeInference> inferType(Type type) {
        var types = bridge.getSupportedValues(SlashCommandOptionType.class)
                .stream()
                .filter((e) ->
                        e != SlashCommandOptionType.UNKNOWN
                        && e != SlashCommandOptionType.SUBCOMMAND
                        && e != SlashCommandOptionType.SUBCOMMAND_GROUP)
                .collect(Collectors.toSet());

        return inferDiscordBridgeType(types, type)
                .map((e) -> new TypeInference(e, false))
                .or(() -> inferImplementationType(types, type)
                        .map((e) -> new TypeInference(e, true)));
    }

    private Optional<? extends SlashCommandOptionType> inferDiscordBridgeType(Set<? extends SlashCommandOptionType> types, Type type) {
        var compatible = types.stream()
                .filter((e) -> TypeUtils.isAssignable(type, e.getTypeRepresentation()))
                .collect(Collectors.toSet());

        return compatible.stream()
                .max(Comparator.comparing((option_type) ->
                        compatible.stream()
                                .filter((e) -> e.getTypeRepresentation()
                                        .isAssignableFrom(option_type.getTypeRepresentation()))
                                .count()));
    }


    private Optional<? extends SlashCommandOptionType> inferImplementationType(Set<? extends SlashCommandOptionType> types, Type type) {
        var compatible = types.stream()
                .filter((e) -> TypeUtils.isAssignable(type, e.getInternalTypeRepresentation(bridge)))
                .collect(Collectors.toSet());

        return compatible.stream()
                .max(Comparator.comparing((option_type) ->
                        compatible.stream()
                                .filter((e) -> e.getTypeRepresentation()
                                        .isAssignableFrom(option_type.getTypeRepresentation()))
                                .count()));
    }



    private LocalizationData parseLocalizationData(Trans[] translations, String parse_trace) {
        logger.debug("parsing localization data {}", (Object)translations);
        var names = new HashMap<DiscordLocale, String>();
        var descriptions = new HashMap<DiscordLocale, String>();

        for (var translation : translations) {
            logger.trace("parsing translation {}", translation);
            var locale = translation.locale();
            var name = translation.name();
            var description = translation.description();

            if (name.isEmpty() && description.isEmpty()) {
                throw new ParsingException("Both name() and description() are empty in @Trans annotation for locale " + locale, parse_trace);
            }
            if (!name.isEmpty()) {
                logger.trace("nonempty name found {}", name);
                if (names.containsKey(locale)) {
                    throw new ParsingException("Duplicate name() for locale " + locale + ", '" + names.get(locale) + "' and '" + name + "'", parse_trace);
                }
                names.put(translation.locale(), translation.name());
            }
            if (!description.isEmpty()) {
                logger.trace("nonempty description found {}", description);
                if (descriptions.containsKey(locale)) {
                    throw new ParsingException("Duplicate description() for locale " + locale + ", '" + descriptions.get(locale) + "' and '" + description + "'", parse_trace);
                }
                descriptions.put(translation.locale(), translation.description());
            }
        }

        return new LocalizationData(names, descriptions);
    }

    private Map<DiscordLocale, String> parseOptionChoiceTranslations(OptionChoiceTrans[] translations, String parse_trace) {
        logger.debug("parsing option choice translations {}", (Object)translations);

        var map = new HashMap<DiscordLocale, String>();

        for (var translation : translations) {
            logger.trace("parsing translation {}", translation);
            var locale = translation.locale();
            var value = translation.value();

            if (value.isEmpty()) {
                throw new ParsingException("value() is empty in @OptionChoiceTrans annotation for locale " + locale, parse_trace);
            }
            if (map.containsKey(locale)) {
                throw new ParsingException("Duplicate value() for locale " + locale + ", '" + map.get(locale) + "' and '" + value + "'", parse_trace);
            }
            map.put(locale, value);
        }

        return map;
    }

    record AutocompleterMethod(Method method, AutocompletableData.Param[] param) {
    }

    private AutocompleterMethod obtainAutocompleterMethod(Class<?> supplier_class, String supplier_method_name, Class<?> parameter_class) throws NoSuchMethodException {
        logger.trace("obtaining autocompleter method from class '{}' with name '{}' for option of type '{}'", supplier_class, supplier_method_name, parameter_class);

        var methods = Stream.of(supplier_class.getDeclaredMethods())
            .filter((e) -> e.getName().equals(supplier_method_name))
            .filter((e) -> {
                logger.trace("filter validating method '{}'", e);
                try {
                    validateAutocompleteSupplierMethod(e, parameter_class);
                    logger.trace("filter success");
                    return true;
                } catch (ParsingException n) {
                    logger.trace("filter fail");
                    return false;
                }
            })
            .flatMap((e) -> {
                logger.trace("parsing method '{}'", e);
                param_parse: {
                    var params = new LinkedHashSet<AutocompletableData.Param>();
                    logger.trace("parsing through parameter types");
                    for (var param : e.getParameters()) {
                        var type = param.getParameterizedType();
                        logger.trace("parsing type '{}'", type);

                        boolean success;
                        if (type == SlashCommandAutocompleteInteraction.class)
                            success = params.add(AutocompletableData.Param.INTERACTION);
                        else if (TypeUtils.isAssignable(parameter_class, type))
                            success = params.add(AutocompletableData.Param.VALUE);
                        else if (TypeUtils.equals(bridge.getImplementationType(SlashCommandAutocompleteInteraction.class).orElse(null), type))
                            success = params.add(AutocompletableData.Param.IMPLEMENTATION_INTERACTION);
                        else {
                            logger.trace("unrecognised type '{}'", type);
                            break param_parse;
                        }

                        if (!success) {
                            logger.trace("parameter type '{}' already encountered", type);
                            break param_parse;
                        }
                    }

                    logger.debug("found valid autocompleter method '{}'", e);
                    return Stream.of(new AutocompleterMethod(e, params.toArray(AutocompletableData.Param[]::new)));
                }
                logger.trace("method parse fail");
                return Stream.empty();
            })
            .collect(Collectors.toSet());

        if (methods.size() == 1) {
            return methods.stream().findAny().get();
        } else if (methods.isEmpty()) {
            throw new ParsingException(
                String.format("""
                    no valid Autocompleter method was found with name '%2$s' in class '%1$s'
                    a valid Autocompleter:
                      - must be annotated with @Autocompleter
                      - must have a return type assignable to List<? extends AutocompleteSuggestion<? extends %3$s>>
                      - must have parameters be of the type AutocompleteInteraction or %3$s with each type appearing at most once
                    """, supplier_class, supplier_method_name, Reflection.toBoxedType(parameter_class).getName()),
                ""
            );
        } else {
            throw new ParsingException(
                "multiple valid Autocompleter methods found: " + methods,
                ""
            );
        }
    }


    @SuppressWarnings("DuplicateExpressions")
    private void validateAutocompleteSupplierMethod(Method method, Class<?> required_class) {
        logger.debug("validating autocomplete supplier method {}", method);
        var supplier_class = method.getDeclaringClass();



        if (method.getDeclaredAnnotation(Autocompleter.class) == null) {
            logger.debug("no @Autocompleter found on method, validation fail");
            throw new ParsingException("Autocomplete supplier method must be annotated with @Autocompleter",
                    "in method " + supplier_class.getName() + "." + method.getName());
        }

        logger.trace("checking method return type");
        if (method.getGenericReturnType() instanceof ParameterizedType list_type
            && list_type.getRawType() == List.class
            && list_type.getActualTypeArguments().length == 1) {
            logger.trace("return type rawtype is List");

            var element_type = list_type.getActualTypeArguments()[0];
            if (element_type instanceof WildcardType bounded_wildcard && bounded_wildcard.getUpperBounds().length == 1) {
                logger.trace("List element type is bounded wildcard, unwrapping");
                element_type = bounded_wildcard.getUpperBounds()[0];
            }
            if (element_type instanceof ParameterizedType data_type && data_type.getRawType() == AutocompleteSuggestion.class
                && data_type.getActualTypeArguments().length == 1) {
                logger.trace("List element rawtype is AutocompleteSuggestion");
                var holding_type = data_type.getActualTypeArguments()[0];

                if (holding_type instanceof WildcardType bounded_wildcard && bounded_wildcard.getUpperBounds().length == 1) {
                    logger.trace("AutocompleteSuggestion element type is bounded wildcard, unwrapping");
                    holding_type = bounded_wildcard.getUpperBounds()[0];
                }

                if (holding_type instanceof Class<?> holding_class
                    && Reflection.toBoxedType(required_class).isAssignableFrom(Reflection.toBoxedType(holding_class))) {
                    logger.trace("Autocomplete Suggestion element type '{}' is assignable to required class '{}', validation success", holding_class, required_class);
                    return;
                }
            }
        }

        throw new ParsingException(
            "Autocomplete supplier method must return List<AutocompleteSuggestion<"
                + required_class.getSimpleName() + ">>",
            "in method " + supplier_class.getName() + "." + method.getName());
    }

    private EnumSet<ChannelType> inferChannelTypeBounds(Type parameter_type) {
        logger.debug("inferring channel type bounds for parameter type {}", parameter_type);

        var set = EnumSet.noneOf(ChannelType.class);

        for (var type : bridge.getSupportedValues(ChannelType.class)) {
            if (type == ChannelType.UNKNOWN)
                continue;
            logger.trace("checking if base api type {} is assignable to {}", type.getTypeRepresentation(), parameter_type);
            if (TypeUtils.isAssignable(type.getTypeRepresentation(), parameter_type)) {
                set.add(type);
            }
            logger.trace("checking if bridge specific type {} is assignable to {}", type.getInternalTypeRepresentation(bridge), parameter_type);
            if (TypeUtils.isAssignable(type.getInternalTypeRepresentation(bridge), parameter_type)) {
                set.add(type);
            }
        }

        logger.debug("inferred channel type bounds for parameter type {}: {}", parameter_type, set);

        return set;
    }

    private SlashCommandData parseFromSlashCommand(SlashCommand command) {
        logger.trace("parsing SlashCommand {}", command);

        var name = command.getName();
        var description = command.getDescription();
        var localizations = new LocalizationData(command.getNameLocalizations(), command.getDescriptionLocalizations());
        var enabled_in_DMs = command.isEnabledInDMs();
        var nsfw = command.isNSFW();

        var options = command.getOptions().stream().map(this::parseFromSlashCommandOption).toList();

        return new SlashCommandData(name, description, localizations, enabled_in_DMs, nsfw, command.getDefaultRequiredPermissions().orElse(null), server_id, options, null, null, false, false);
    }
    @SuppressWarnings({"unchecked", "rawtypes"})
    private SlashCommandOptionData<?> parseFromSlashCommandOption(SlashCommandOption option) {
        logger.trace("parsing SlashCommandOption {}", option);

        var name = option.getName();
        var description = option.getDescription();
        var localizations = new LocalizationData(option.getNameLocalizations(), option.getDescriptionLocalizations());
        var required = option.isRequired();
        var type = option.getType();
        var options = option.getOptions().stream().map(this::parseFromSlashCommandOption).toList();
        var choices = option.getChoices().stream().map(this::parseFromSlashCommandOptionChoice).toList();

        var bounds = switch (type) {
            case CHANNEL -> new ChannelTypeBoundsData(option.getChannelTypeBounds());
            case NUMBER -> new DoubleBoundsData(
                option.getNumberBoundsMin().orElse(Double.NEGATIVE_INFINITY),
                option.getNumberBoundsMax().orElse(Double.POSITIVE_INFINITY)
            );
            case INTEGER -> new LongBoundsData(
                option.getIntegerBoundsMin().orElse(Long.MIN_VALUE),
                option.getIntegerBoundsMax().orElse(Long.MAX_VALUE)
            );
            case STRING -> new StringLengthBoundsData(
                option.getStringLengthBoundsMin().orElse(0L),
                option.getStringLengthBoundsMax().orElse(Long.MAX_VALUE)
            );
            default -> null;
        };

        return new SlashCommandOptionData(name, description, localizations, required, type, false, options, choices, null, null, null, false, false, false, bounds);
    }
    private SlashCommandOptionChoiceData<?> parseFromSlashCommandOptionChoice(SlashCommandOptionChoice choice) {
        logger.trace("parsing SlashCommandOptionChoice {}", choice);

        var name = choice.getName();
        if (choice.getValue(Long.class).isPresent()) {
            return new SlashCommandOptionChoiceData<Long>(name, choice.getValue(Long.class).get(), choice.getNameLocalizations());
        } else if (choice.getValue(String.class).isPresent()) {
            return new SlashCommandOptionChoiceData<String>(name, choice.getValue(String.class).get(), choice.getNameLocalizations());
        } else {
            throw new IllegalArgumentException("SlashCommandOptionChoice from server has neither a long value nor a string value");
        }
    }
}
