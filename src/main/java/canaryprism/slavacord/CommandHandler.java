/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package canaryprism.slavacord;

import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;
import java.lang.invoke.MethodHandle;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.NoSuchElementException;
import java.util.Objects;

import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.javacord.api.DiscordApi;
import org.javacord.api.entity.message.MessageFlag;
import org.javacord.api.event.interaction.SlashCommandCreateEvent;
import org.javacord.api.interaction.SlashCommand;
import org.javacord.api.interaction.SlashCommandInteraction;
import org.javacord.api.interaction.SlashCommandInteractionOptionsProvider;
import org.javacord.api.interaction.SlashCommandOption;
import org.javacord.api.interaction.SlashCommandOptionChoice;
import org.javacord.api.listener.interaction.SlashCommandCreateListener;

import canaryprism.slavacord.annotations.*;
import canaryprism.slavacord.data.*;
import canaryprism.slavacord.exceptions.ParsingException;

/**
 * <h2>The main command handler of this library.</h2>
 * 
 * <p>
 * This class is responsible for handling all the commands and command groups
 * </p>
 */
public class CommandHandler {

    private static final Logger logger = LogManager.getLogger(CommandHandler.class);

    private final DiscordApi api;

    private final SlashCommandCreateListener listener;

    private ArrayList<SlashCommandData> commands = new ArrayList<>();
    
    private final Map<Method, MethodHandle> methodmap = new HashMap<>();

    /**
     * <p>Creates a new CommandHandler with the given DiscordApi</p>
     * @param api the DiscordApi to use, cannot be null
     */
    public CommandHandler(DiscordApi api) {
        this.api = Objects.requireNonNull(api, "DiscordApi cannot be null");

        this.listener = this::listener;

        this.api.addSlashCommandCreateListener(listener);
    }

    private static final Pattern space_pattern = Pattern.compile(" ");

    private void listener(SlashCommandCreateEvent e) {
        var interaction = e.getSlashCommandInteraction();
        var names = space_pattern.split(interaction.getFullCommandName());

        synchronized (commands) {
            commands.forEach((command) -> findMethodAndExecute(names, 0, interaction, interaction, command, null));
        }
    }

    private void findMethodAndExecute(String[] names, int index, SlashCommandInteraction interaction, SlashCommandInteractionOptionsProvider interaction_options, SlashCommandData command, SlashCommandOptionData<?> option) {

        String looking_for = names[index];

        Method method;
        Object instance;
        String name;
        List<SlashCommandOptionData<?>> options;
        boolean requires_interaction;
        if (command == null) {
            method = option.method();
            instance = option.instance();
            name = option.name();
            options = option.options();
            requires_interaction = option.requires_interaction();
        } else {
            method = command.method();
            instance = command.instance();
            name = command.name();
            options = command.options();
            requires_interaction = command.requires_interaction();
        }

        if (name.equals(looking_for)) {
            if (index == names.length - 1) {
                if (method == null) {
                    throw new IllegalArgumentException("SlashCommandData has no method");
                }

                if (!methodmap.containsKey(method)) {
                    try {
                        methodmap.put(method, MethodHandles.lookup().unreflect(method));
                    } catch (IllegalAccessException e) {
                        throw new NoSuchElementException(e);
                    }
                }
                var handle = Objects.requireNonNull(methodmap.get(method));
                var parameters = new ArrayList<Object>();
                if (!Modifier.isStatic(method.getModifiers())) {
                    parameters.add(Objects.requireNonNull(instance, "Instance not found for non-static method"));
                }
                if (requires_interaction) {
                    parameters.add(interaction);
                }
                if (options != null) {
                    for (int i = 0; i < options.size(); i++) {
                        var option_type = options.get(i).type();
                        boolean is_required = options.get(i).required();
                        if (!options.get(i).stores_enum()) {
                            if (is_required)
                                switch (option_type) {
                                    case STRING -> parameters.add(interaction_options.getArgumentStringValueByName(options.get(i).name()).get());
                                    case LONG -> parameters.add(interaction_options.getArgumentLongValueByName(options.get(i).name()).get());
                                    case BOOLEAN -> parameters.add(interaction_options.getArgumentBooleanValueByName(options.get(i).name()).get());
                                    case USER -> parameters.add(interaction_options.getArgumentUserValueByName(options.get(i).name()).get());
                                    case CHANNEL -> parameters.add(interaction_options.getArgumentChannelValueByName(options.get(i).name()).get());
                                    case ROLE -> parameters.add(interaction_options.getArgumentRoleValueByName(options.get(i).name()).get());
                                    case MENTIONABLE -> parameters.add(interaction_options.getArgumentMentionableValueByName(options.get(i).name()).get());
                                    default -> throw new IllegalArgumentException("Invalid option type");
                                }
                            else
                                switch (option_type) {
                                    case STRING -> parameters.add(interaction_options.getArgumentStringValueByName(options.get(i).name()));
                                    case LONG -> parameters.add(interaction_options.getArgumentLongValueByName(options.get(i).name()));
                                    case BOOLEAN -> parameters.add(interaction_options.getArgumentBooleanValueByName(options.get(i).name()));
                                    case USER -> parameters.add(interaction_options.getArgumentUserValueByName(options.get(i).name()));
                                    case CHANNEL -> parameters.add(interaction_options.getArgumentChannelValueByName(options.get(i).name()));
                                    case ROLE -> parameters.add(interaction_options.getArgumentRoleValueByName(options.get(i).name()));
                                    case MENTIONABLE -> parameters.add(interaction_options.getArgumentMentionableValueByName(options.get(i).name()));
                                    default -> throw new IllegalArgumentException("Invalid option type");
                                }
                        } else {
                            if (option_type != org.javacord.api.interaction.SlashCommandOptionType.LONG) {
                                throw new IllegalArgumentException("Invalid option type for enum");
                            }
                            if (is_required) {
                                parameters.add(options.get(i).choices().get(
                                        interaction_options.getArgumentLongValueByName(
                                            options.get(i).name()
                                        ).get().intValue()
                                    ).value()
                                );
                            } else {
                                if (interaction_options.getArgumentLongValueByName(options.get(i).name()).isPresent())
                                    parameters.add(Optional.of(
                                        options.get(i).choices().get(
                                            interaction_options.getArgumentLongValueByName(options.get(i).name()).get().intValue()
                                        ).value()
                                    ));
                                else
                                    parameters.add(Optional.empty());
                            }
                        }
                    }
                }

                final Async async = isAsyncRecursive(method);
                final ReturnsResponse returns_response = method.getDeclaredAnnotation(ReturnsResponse.class);

                if (async == null) {
                    try {
                        Object returned = handle.invokeWithArguments(parameters);
                        
                        if (returns_response != null && returned != null && !((String)returned).isBlank()) {
                            processImmediateRespond(interaction, returns_response, method.getGenericReturnType(), returned);
                        }
                    } catch (Throwable e) {
                        logger.error("Exception in event listener thread: ", e);
                    }
                } else {
                    dispatchThreaded(() -> {
                        try {

                            if (returns_response != null) {
                                if (async != null && async.respondLater()) {
                                    var responder = interaction.respondLater(returns_response.ephemeral()).join();
                                    Object returned = handle.invokeWithArguments(parameters);

                                    if (returned != null && !((String)returned).isBlank()) {

                                        if (returns_response.ephemeral()) {
                                            responder.setFlags(MessageFlag.EPHEMERAL);
                                        }
                                        if (returns_response.silent()) {
                                            responder.setFlags(MessageFlag.SUPPRESS_NOTIFICATIONS);
                                        }

                                        if (returns_response.splitOnLimit()) {
                                            var split = splitString((String)returned, 2000);
                                            responder.setContent(split[0]);
                                            responder.update().join();

                                            var followup = interaction.createFollowupMessageBuilder();

                                            if (returns_response.ephemeral()) {
                                                followup.setFlags(MessageFlag.EPHEMERAL);
                                            }
                                            if (returns_response.silent()) {
                                                followup.setFlags(MessageFlag.SUPPRESS_NOTIFICATIONS);
                                            }

                                            for (int i = 1; i < split.length; i++) {
                                                followup.setContent(split[i]);
                                                followup.send().join();
                                            }

                                        } else {
                                            responder.setContent((String)returned);
                                            responder.update().join();
                                        }

                                    }
                                } else {
                                    Object returned = handle.invokeWithArguments(parameters);
                                    processImmediateRespond(interaction, returns_response, method.getGenericReturnType(), returned);
                                }


                            } else {
                                handle.invokeWithArguments(parameters);
                            }
                        } catch (Throwable e) {
                            logger.error("Exception in command execution thread", e);
                        }
                    }, (async.threadingMode() != ThreadingMode.none)? async.threadingMode() : threading_mode);
                }


            
            } else {
                if (options == null) {
                    throw new IllegalArgumentException("SlashCommandData has no options");
                }
                for (var e : options) {
                    try {
                        findMethodAndExecute(names, index + 1, interaction, interaction_options.getOptionByName(e.name()).get(), null, e);
                    } catch (NoSuchElementException n) {
                        // ignore
                    }
                }
            }
        }

    }

    private volatile ThreadingMode threading_mode = ThreadingMode.prefervirtual;

    /**
     * <p>sets the default threading mode that is used when a command doesn't specify what mode to use itself</p>
     * <p>default value is {@link ThreadingMode#prefervirtual}
     * @param mode the mode to use
     */
    public void setDefaultThreadingMode(ThreadingMode mode) {
        threading_mode = mode;
    }

    private static final ExecutorService osthread_ex = Executors.newCachedThreadPool();
    private static final ExecutorService daemonthread_ex = Executors.newCachedThreadPool((r) -> {
        var t = new Thread(r);
        t.setDaemon(true);
        return t;
    });
    private static final Optional<ExecutorService> vthread_ex;
    static {
        Optional<ExecutorService> handle = Optional.empty();
        try {
            var vthread_executor_getter = Class.forName("java.util.concurrent.Executors").getDeclaredMethod("newVirtualThreadPerTaskExecutor");
            handle = Optional.of((ExecutorService)vthread_executor_getter.invoke(null));

            logger.debug("Virtual thread support found for this JVM");
        } catch (Exception e) {
            logger.info("No virtual thread support found for this JVM");
        }
        vthread_ex = handle;
    }

    private static void dispatchThreaded(Runnable runnable, ThreadingMode mode) {
        var dispatcher = switch (mode) {
            case platform -> osthread_ex;
            case virtual -> vthread_ex.orElseThrow(() -> new UnsupportedOperationException("No virtual thread support found for this JVM"));
            case daemon -> daemonthread_ex;
            case prefervirtual -> vthread_ex.orElse(osthread_ex);
            case none -> throw new UnsupportedOperationException("ThreadingMode.none is not allowed here");
        };
        if (dispatcher != null) {
            dispatcher.submit(runnable);
        } else {
            runnable.run();
        }
    }

    private String[] splitString(String text, int every) {
        List<String> results = new ArrayList<>();
        int length = text.length();

        for (int i = 0; i < length; i += every) {
            results.add(text.substring(i, Math.min(length, i + every)));
        }

        return results.toArray(String[]::new);
    }

    private void processImmediateRespond(SlashCommandInteraction interaction, ReturnsResponse returns_response, Type return_type, Object returned) {

        String text;

        if (return_type.equals(String.class)) {
            var str = (String)returned;
            if (str == null) {
                return; // we don't respond if the returned string is null
            }
            if (str.isBlank()) {
                /* 
                 * if the returned string is blank, we don't respond
                 * this is because you can't even send a blank message to discord
                 * this is technically a valid way to not respond to a command
                 * but it's likely also a developer error
                 * because of this, we log a warning
                 */

                logger.warn("""
                    Command with @ReturnsResponse returned a blank string! 
                    CommandHandler will interpret this as returning without responding to the interaction FOR NOW, but this is likely a developer error.
                    prefer returning null or an empty Optional<String> instead of a blank string to not respond to the interaction.
                    """);

                return;
            }

            text = str;
        } else if (return_type.equals(OPTIONAL_OF_STRING)) {
            var opt = (Optional<?>)returned;
            if (opt == null) {
                // an Optional implies a contract that it will never be null
                // this will not be treated as a valid value
                throw new IllegalArgumentException("Invalid return value for @ReturnsResponse. you may not return a null Optional");
            }
            if (opt.isEmpty()) {
                return; // we don't respond if the returned optional is empty
            }

            text = (String)opt.get();
        } else {
            throw new IllegalArgumentException("Invalid return type for @ReturnsResponse"); // this should never happen
        }

        var responder = interaction.createImmediateResponder();

        if (returns_response.ephemeral()) {
            responder.setFlags(MessageFlag.EPHEMERAL);
        }
        if (returns_response.silent()) {
            responder.setFlags(MessageFlag.SUPPRESS_NOTIFICATIONS);
        }
        if (returns_response.splitOnLimit()) {
            var split = splitString(text, 2000);
            responder.setContent(split[0]);
            responder.respond().join();

            var followup = interaction.createFollowupMessageBuilder();

            if (returns_response.ephemeral()) {
                followup.setFlags(MessageFlag.EPHEMERAL);
            }
            if (returns_response.silent()) {
                followup.setFlags(MessageFlag.SUPPRESS_NOTIFICATIONS);
            }

            for (int i = 1; i < split.length; i++) {
                followup.setContent(split[i]);
                followup.send().join();
            }

        } else {
            responder.setContent(text);
            responder.respond().join();
        }
    }

    private Async isAsyncRecursive(Method method) {
        if (method.getDeclaredAnnotation(Async.class) != null) {
            return method.getDeclaredAnnotation(Async.class);
        }
        var enclosing = method.getDeclaringClass();
        var root = Commands.class;
        while (enclosing != null && !root.isInstance(enclosing)) {
            if (enclosing.getDeclaredAnnotation(Async.class) != null) {
                return enclosing.getDeclaredAnnotation(Async.class);
            }
            enclosing = enclosing.getEnclosingClass();
        }
        return null;
    }

    /**
     * <p>unregisters the event listener</p>
     * <p>once you call this method there is no way to reactivate the event listener of this instance ever again</p>
     * <p>this also technically doesn't stop you from registering more commands after you call it, the listener just won't work obviously</p>
     */
    public void stop() {
        api.removeListener(listener);
    }

    /**
     * <p>Registers a {@link Commands} <em>class</em> to be parsed by the {@link CommandHandler}</p>
     * <p>if any of the commands are in instance methods, you must use {@link #register(Commands, boolean)} and pass an instance instead</p>
     * <p>
     * if the class could be parsed successfully, the commands that were parsed will take effect 
     * and be registered with Discord. if not, this will throw a {@link ParsingException}
     * </p>
     * 
     * <p>
     * if overwrites is true, all previous commands registered by the bot <b>will be deleted from discord</b>. 
     * yes, even the ones previously registered to this command handler.
     * 
     * if overwrites is false, the command handler will attempt to get the existing commands from discord, and merge them with the new commands.
     * </p>
     * 
     * @param target the Class object of the Commands class to parse, must not be null
     * @param overwrites whether or not to overwrite existing commands
     */
    public void register(Class<? extends Commands> target, boolean overwrites) {
        this.register(null, target, overwrites);
    }

    /**
     * <p>Registers a {@link Commands} <em>instance</em> to be parsed by the {@link CommandHandler}</p>
     * <p>if all of the commands are in static methods, consider using {@link #register(Class, boolean)} and pass the Class object instead</p>
     * <p>
     * if the class of the instance could be parsed successfully, the commands that were parsed will take effect 
     * and be registered with Discord. if not, this will throw a {@link ParsingException}
     * </p>
     * 
     * <p>
     * if overwrites is true, all previous commands registered by the bot <b>will be deleted from discord</b>. 
     * yes, even the ones previously registered to this command handler.
     * 
     * if overwrites is false, the command handler will attempt to get the existing commands from discord, and merge them with the new commands.
     * </p>
     * 
     * @param target_instance the instance of the Commands class to parse, must not be null
     * @param overwrites whether or not to overwrite existing commands
     */
    public void register(Commands target_instance, boolean overwrites) {
        // technically this null check is not needed because we access the getClass() method on the exact same line but it's here for clarity
        this.register(Objects.requireNonNull(target_instance, "Commands instance cannot be null"), target_instance.getClass(), overwrites);
    }

    @SuppressWarnings("java:S127")
    private void register(Commands target_instance, Class<? extends Commands> target, boolean overwrites) {
        server_id = -1;

        var new_commands = new ArrayList<SlashCommandData>();
        parseFromClass(target_instance, target, 0, new_commands);

        //yell about duplicate names
        for (int i = 0; i < new_commands.size(); i++) {
            for (int j = i + 1; j < new_commands.size(); j++) {
                if (new_commands.get(i).name().equals(new_commands.get(j).name()) && new_commands.get(i).server_id() == new_commands.get(j).server_id()) {
                    throw new ParsingException(
                        "Duplicate command name /" + new_commands.get(i).name(), 
                        "at class " + target.getName()
                    );
                }
            }
        }

        var processed_commands = new ArrayList<SlashCommandData>();


        var to_add = new ArrayList<SlashCommandData>();
        if (server_id == 0) {
            
            
            if (!overwrites) {
                to_add.addAll(api.getGlobalSlashCommands().join().stream().map(this::parseFromSlashCommand).toList());

                // remove duplicates from new_commands
                var it = new_commands.listIterator();
                while (it.hasNext()) {
                    var command = it.next();
                    if (to_add.contains(command)) {
                        it.remove();
                    }
                }
            }
            to_add.addAll(new_commands);
            api.bulkOverwriteGlobalApplicationCommands(to_add.stream().map(SlashCommandData::toSlashCommandBuilder).collect(Collectors.toSet())).join();
            processed_commands.addAll(new_commands);
        } else {
            if (!overwrites) {
                to_add.addAll(api.getServerSlashCommands(api.getServerById(server_id).get()).join().stream().map(this::parseFromSlashCommand).toList());

                for (int i = 0; i < to_add.size(); i++) {
                    if (to_add.contains(to_add.get(i))) {
                        to_add.remove(i--);
                    }
                }
            }
            to_add.addAll(new_commands);
            api.bulkOverwriteServerApplicationCommands(server_id, to_add.stream().map(SlashCommandData::toSlashCommandBuilder).collect(Collectors.toSet())).join();
            processed_commands.addAll(new_commands);
        }

        synchronized (commands) {
            if (!overwrites) {
                for (int i = 0; i < processed_commands.size(); i++) {
                    for (int j = 0; j < commands.size(); j++) {
                        if (processed_commands.get(i).name().equals(commands.get(j).name()) 
                            && processed_commands.get(i).server_id() == commands.get(j).server_id()
                            && !processed_commands.get(i).equals(commands.get(j))) {
                            commands.remove(j--);
                        }
                    }
                }
            } else {
                for (int i = 0; i < commands.size(); i++) {
                    if (commands.get(i).server_id() == server_id) {
                        commands.remove(i--);
                    }
                }
            }

            commands.addAll(processed_commands);
        }
    }

    private long server_id;

    private static final MethodHandle custom_name_getter;
    static {
        try {
            custom_name_getter = MethodHandles.lookup().findVirtual(CustomChoiceName.class, "getCustomName", MethodType.methodType(String.class));
        } catch (Exception e) {
            throw new NoSuchElementException(e); // this should never happen
        }
    }

    private static final ParameterizedType OPTIONAL_OF_STRING = new ParameterizedType() {
        @Override
        public Type[] getActualTypeArguments() {
            return new Type[] { String.class };
        }
        @Override
        public Type getRawType() {
            return Optional.class;
        }
        @Override
        public Type getOwnerType() {
            return null;
        }
    };

    @SuppressWarnings({ "unchecked", "java:S3011" })
    private void parseFromClass(Object instance, Class<?> target, int depth, ArrayList<? extends Data> target_list) {

        if (depth > 2) {
            throw new ParsingException("you are not allowed to nest commands more than 2 levels deep", "at class " + target.getName());
        }

        if (target.getMethods().length + target.getDeclaredClasses().length == 0 && depth != 0) {
            throw new ParsingException("you are not allowed to have an empty command group", "at class " + target.getName());
        }

        var create_global = target.getDeclaredAnnotation(CreateGlobal.class);
        var create_server = target.getDeclaredAnnotation(CreateServer.class);
        if (create_global != null && create_server != null) {
            throw new ParsingException("you are not allowed to use both @CreateGlobal and @CreateServer", "at class " + target.getName());
        }
        if (create_global != null) {
            if (depth != 0) {
                throw new ParsingException("you are not allowed to use @CreateGlobal on a command group", "at class " + target.getName());
            }
            server_id = 0;
        }
        if (create_server != null) {
            if (depth != 0) {
                throw new ParsingException("you are not allowed to use @CreateServer on a command group", "at class " + target.getName());
            }
            server_id = create_server.value();
        }
        if (create_global == null && create_server == null && depth == 0) {
            throw new ParsingException("a root Commandable requires either @CreateGlobal or @CreateServer", "at class " + target.getName());
        }


        try {
            for (var method : target.getDeclaredMethods()) {
                var command = method.getDeclaredAnnotation(Command.class);
                if (command == null) continue;

                if (instance == null && !Modifier.isStatic(method.getModifiers())) {
                    throw new ParsingException("Command method must be static if no instance of Commandable is provided", "in method " + target.getName() + "." + method.getName());
                }

                method.setAccessible(true);

                ReturnsResponse returns_response = method.getDeclaredAnnotation(ReturnsResponse.class);
                if (returns_response != null && method.getReturnType() != String.class
                    && !method.getGenericReturnType().equals(OPTIONAL_OF_STRING))
                    throw new ParsingException("Method with @ReturnsResponse must return a String or Optional<String>", "in method " + target.getName() + "." + method.getName());

                if (returns_response != null && returns_response.ephemeral() && returns_response.silent())
                    throw new ParsingException("@ReturnsResponse cannot have both ephemeral and silent set to true", "in method " + target.getName() + "." + method.getName());

                if ((method.getDeclaredAnnotation(Async.class)) != null && vthread_ex.isEmpty())
                    throw new ParsingException("Virtual threads are not supported on this JVM", "in method " + target.getName() + "." + method.getName());

                var name = command.name();
                var description = command.description();

                boolean skip_next_interaction_parameter = false;
                boolean requires_interaction = false;
                try {
                    if (method.getParameters()[0].getDeclaredAnnotation(Interaction.class) != null) {
                        skip_next_interaction_parameter = true;
                        requires_interaction = true;
                        if (method.getParameters()[0].getType() != org.javacord.api.interaction.SlashCommandInteraction.class)
                            throw new ParsingException("@Interaction can only be applied to the first parameter with type org.javacord.api.interaction.SlashCommandInteraction", "with parameter " + target.getName() + "." + method.getName() + "(" + method.getParameters()[0].getType().getSimpleName() + " " + method.getParameters()[0].getName() + ")");
                    }
                } catch (ArrayIndexOutOfBoundsException e) {
                    // do nothing
                }

                ArrayList<SlashCommandOptionData<?>> options = new ArrayList<>();
                try {
                    for (var parameter : method.getParameters()) {
                        if (parameter.getAnnotation(Interaction.class) != null) {
                            if (skip_next_interaction_parameter) {
                                skip_next_interaction_parameter = false;
                                continue;
                            }
                            throw new ParsingException("@Interaction can only be applied to the first parameter with type org.javacord.api.interaction.SlashCommandInteraction", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");

                        }

                        var option = parameter.getDeclaredAnnotation(Option.class);
                        if (option == null) 
                            throw new ParsingException("All parameters must have either @Interaction or @Option", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");

                        var parameter_type = parameter.getParameterizedType().getTypeName();
                        Class<?> inner_class = null;
                        try {
                            inner_class = Class.forName(
                                (parameter_type.startsWith("java.util.Optional"))?
                                parameter_type.split("<")[1].split(">")[0] :
                                parameter_type
                            );
                        } catch (ClassNotFoundException e) {
                            inner_class = CommandHandler.class; //this is a hack to make the switch statement work lmfao
                        }

                        var option_type = switch (
                            (!inner_class.isEnum())? (
                                (parameter_type.startsWith("java.util.Optional"))?
                                    parameter_type.split("<")[1].split(">")[0] 
                                :
                                    parameter_type
                            ) :
                                "enum"
                        ) {
                            case "java.lang.String" -> org.javacord.api.interaction.SlashCommandOptionType.STRING;
                            case "long" -> org.javacord.api.interaction.SlashCommandOptionType.LONG;
                            case "java.lang.Long" -> org.javacord.api.interaction.SlashCommandOptionType.LONG;
                            case "boolean" -> org.javacord.api.interaction.SlashCommandOptionType.BOOLEAN;
                            case "java.lang.Boolean" -> org.javacord.api.interaction.SlashCommandOptionType.BOOLEAN;
                            case "org.javacord.api.entity.user.User" -> org.javacord.api.interaction.SlashCommandOptionType.USER;
                            case "org.javacord.api.entity.channel.ServerChannel" -> org.javacord.api.interaction.SlashCommandOptionType.CHANNEL;
                            case "org.javacord.api.entity.Role" -> org.javacord.api.interaction.SlashCommandOptionType.ROLE;
                            case "org.javacord.api.entity.Mentionable" -> org.javacord.api.interaction.SlashCommandOptionType.MENTIONABLE;

                            case "enum" -> org.javacord.api.interaction.SlashCommandOptionType.LONG;

                            default -> throw new ParsingException("Invalid parameter type, only types supported by Discord can be used", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                        };

                        var option_name = option.name();
                        var option_description = option.description().isEmpty()? option_name : option.description();
                        var option_required = !parameter.getParameterizedType().getTypeName().contains("java.util.Optional");
                        var option_string_choices = option.stringChoices();
                        var option_long_choices = option.longChoices();

                        boolean has_choices = false;

                        if (option_string_choices.length > 0) {
                            var optionchoices = new ArrayList<SlashCommandOptionChoiceData<String>>();
                            if (option_type != org.javacord.api.interaction.SlashCommandOptionType.STRING) {
                                throw new ParsingException("Option Choices type does not match parameter", "with parameter " + target.getName() + "." + method.getName() + "(" + parameter.getType().getSimpleName() + " " + parameter.getName() + ")");
                            }
                            for (var choice : option_string_choices) {
                                optionchoices.add(new SlashCommandOptionChoiceData<String>(choice.name().equals("")? choice.value() : choice.name(), choice.value()));
                            }
                            options.add(new SlashCommandOptionData<String>(
                                option_name, 
                                option_description, 
                                option_required, 
                                option_type, 
                                null, 
                                optionchoices, 
                                null,
                                null,
                                false,
                                false
                            ));
                            has_choices = true;
                        } else if (option_long_choices.length > 0) {
                            var optionchoices = new ArrayList<SlashCommandOptionChoiceData<Long>>();
                            if (option_type != org.javacord.api.interaction.SlashCommandOptionType.LONG) {
                                throw new ParsingException("Invalid option choice type at parameter " + parameter.getName() + " in method " + method.getName(), "at class " + target.getName());
                            }
                            for (var choice : option_long_choices) {
                                optionchoices.add(new SlashCommandOptionChoiceData<Long>(choice.name(), choice.value()));
                            }
                            options.add(new SlashCommandOptionData<Long>(
                                option_name, 
                                option_description, 
                                option_required, 
                                option_type, 
                                null, 
                                optionchoices, 
                                null,
                                null,
                                false,
                                false
                            ));
                            has_choices = true;
                        } else if (inner_class.isEnum()) {
                            var optionchoices = new ArrayList<SlashCommandOptionChoiceData<Enum<?>>>();
                            if (option_type != org.javacord.api.interaction.SlashCommandOptionType.LONG) {
                                throw new ParsingException("Invalid option choice type at parameter " + parameter.getName() + " in method " + method.getName(), "at class " + target.getName());
                            }
                            if (CustomChoiceName.class.isAssignableFrom(inner_class)) {
                                for (var choice : inner_class.getEnumConstants()) {
                                    try {
                                        var choicename = custom_name_getter.invoke(choice).toString();
                                        if (choicename.isBlank()) {
                                            throw new ParsingException("CustomChoiceName.getCustomName() must return a non-blank string", "at class " + target.getName());
                                        }
                                        if (choicename.length() > 25) {
                                            throw new ParsingException("CustomChoiceName.getCustomName() must return a string with a length of 25 characters or less", "at class " + target.getName());
                                        }
                                        optionchoices.add(new SlashCommandOptionChoiceData<Enum<?>>(choicename, ((Enum<?>)choice)));
                                    } catch (Throwable e) {
                                        throw new ParsingException("Exception while trying to get custom name", "at class " + target.getName(), e);
                                    }
                                }
                            } else {
                                for (var choice : inner_class.getEnumConstants()) {
                                    optionchoices.add(new SlashCommandOptionChoiceData<Enum<?>>(choice.toString().replaceAll("(?<=.{25}).", ""), ((Enum<?>)choice)));
                                }
                            }
                            options.add(new SlashCommandOptionData<Enum<?>>(
                                option_name, 
                                option_description, 
                                option_required, 
                                option_type, 
                                null, 
                                optionchoices, 
                                null,
                                null,
                                false,
                                true
                            ));
                            has_choices = true;
                        }
                        if (!has_choices)
                            options.add(new SlashCommandOptionData<Long>(
                                option_name, 
                                option_description, 
                                option_required, 
                                option_type, 
                                null, 
                                null, 
                                null,
                                null,
                                false,
                                false
                            ));
                    }
                } catch (ParsingException e) {
                    throw e.addParseTrace("in method " + target.getName() + "." + method.getName());
                }
                if (depth == 0) {
                    ((ArrayList<SlashCommandData>) target_list).add(new SlashCommandData(
                        name, 
                        description, 
                        (server_id == 0) && command.enabledInDMs(), 
                        server_id, 
                        options, 
                        method,
                        instance,
                        requires_interaction
                    ));
                } else {
                    ((ArrayList<SlashCommandOptionData<?>>) target_list).add(new SlashCommandOptionData<Long>(
                        name, 
                        description, 
                        false, 
                        org.javacord.api.interaction.SlashCommandOptionType.SUB_COMMAND, 
                        options, 
                        null, 
                        method,
                        instance,
                        requires_interaction,
                        false
                    ));
                }

            }
            for (var group : target.getDeclaredClasses()) {
                var group_of_commands = group.getDeclaredAnnotation(CommandGroup.class);
                if (group_of_commands == null) continue;

                var name = group_of_commands.name();
                var description = group_of_commands.description();

                if (description.isBlank()) {
                    description = name;
                }

                ArrayList<SlashCommandOptionData<?>> options = new ArrayList<>();

                Object group_instance;
                if (instance == null) {
                    group_instance = null;
                } else {
                    if (Modifier.isStatic(group.getModifiers())) {
                        try {
                            var constructor = group.getDeclaredConstructor();
                            constructor.setAccessible(true);
                            group_instance = constructor.newInstance();
                        } catch (NoSuchMethodException e) {
                            throw new ParsingException("GroupOfCommands class must have a no-args constructor", "at class " + target.getName());
                        } catch (Exception e) {
                            throw new ParsingException("Exception while trying to instantiate class", "at class " + target.getName(), e);
                        }
                    } else {
                        try {
                            var constructor = group.getDeclaredConstructor(target);
                            constructor.setAccessible(true);
                            group_instance = constructor.newInstance(instance);
                        } catch (NoSuchMethodException e) {
                            throw new ParsingException("GroupOfCommands class must have a no-args constructor", "at class " + target.getName());
                        } catch (Exception e) {
                            throw new ParsingException("Exception while trying to instantiate class", "at class " + target.getName(), e);
                        }
                    }
                }



                
                parseFromClass(group_instance, group, depth + 1, options);

                if (depth == 0) {
                    ((ArrayList<SlashCommandData>) target_list).add(new SlashCommandData(
                        name, 
                        description, 
                        (server_id == 0) && group_of_commands.enabledInDMs(), 
                        server_id, 
                        options, 
                        null,
                        null,
                        true
                    ));
                } else {
                    ((ArrayList<SlashCommandOptionData<?>>) target_list).add(new SlashCommandOptionData<Long>(
                        name, 
                        description, 
                        false, 
                        org.javacord.api.interaction.SlashCommandOptionType.SUB_COMMAND_GROUP, 
                        options, 
                        null, 
                        null,
                        null,
                        true,
                        false
                    ));
                }
            }
        } catch (ParsingException e) {
            throw e.addParseTrace("at class " + target.getName());
        }
    }

    @SuppressWarnings("unchecked")
    private SlashCommandData parseFromSlashCommand(SlashCommand command) {
        var name = command.getName();
        var description = command.getDescription();
        var enabled_in_DMs = command.isEnabledInDms();

        var options = command.getOptions().stream().map(this::parseFromSlashCommandOption).toList();

        return new SlashCommandData(name, description, enabled_in_DMs, server_id, (List<SlashCommandOptionData<?>>) options, null, null, false);
    }
    @SuppressWarnings({"unchecked", "rawtypes"})
    private SlashCommandOptionData<?> parseFromSlashCommandOption(SlashCommandOption option) {
        var name = option.getName();
        var description = option.getDescription();
        var required = option.isRequired();
        var type = option.getType();
        var options = option.getOptions().stream().map(this::parseFromSlashCommandOption).toList();
        var choices = option.getChoices().stream().map(this::parseFromSlashCommandOptionChoice).toList();
        return new SlashCommandOptionData(name, description, required, type, options, choices, null, null, false, false);
    }
    private SlashCommandOptionChoiceData<?> parseFromSlashCommandOptionChoice(SlashCommandOptionChoice choice) {
        var name = choice.getName();
        if (choice.getLongValue().isPresent()) {
            return new SlashCommandOptionChoiceData<Long>(name, choice.getLongValue().get());
        } else if (choice.getStringValue().isPresent()) {
            return new SlashCommandOptionChoiceData<String>(name, choice.getStringValue().get());
        } else {
            throw new IllegalArgumentException("SlashCommandOptionChoice from server has neither a long value nor a string value");
        }
    }
}
